<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzulihrs.github.io</id>
    <title>blog</title>
    <updated>2022-01-02T07:19:34.040Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzulihrs.github.io"/>
    <link rel="self" href="https://zzulihrs.github.io/atom.xml"/>
    <subtitle>fw</subtitle>
    <logo>https://zzulihrs.github.io/images/avatar.png</logo>
    <icon>https://zzulihrs.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, blog</rights>
    <entry>
        <title type="html"><![CDATA[随便写写题]]></title>
        <id>https://zzulihrs.github.io/post/sui-bian-xie-xie-ti/</id>
        <link href="https://zzulihrs.github.io/post/sui-bian-xie-xie-ti/">
        </link>
        <updated>2022-01-02T07:11:11.000Z</updated>
        <content type="html"><![CDATA[<p>2022/01/02</p>
<h1 id="5970-参加会议的最多员工数"><a href="https://leetcode-cn.com/contest/weekly-contest-274/problems/maximum-employees-to-be-invited-to-a-meeting/">5970. 参加会议的最多员工数</a></h1>
<p>leetcode第274周赛D题<br>
还是挺有意思<br>
思路：<br>
两种情况<br>
1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况<br>
2）最大环，只能放一个<br>
取两种情况的最大值</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

class Solution {
public:
	#define maxsize 100010
	#define pb push_back
	#define fi first
	#define se second
	#define SZ(x) (int)x.size()
	#define ALL(x) x.begin(), x.end()
	/*
	两种情况
	1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况
	2）最大环，只能放一个
	取两种情况的最大值
	*/

	vector&lt;int&gt; e[maxsize], re[maxsize];
	int d[maxsize];

    int maximumInvitations(vector&lt;int&gt;&amp; a) {
    	int n = SZ(a);

  		for(int i = 0; i &lt; SZ(a); ++i)
  		{
  			e[i].pb(a[i]);
  			re[a[i]].pb(i);
  			d[a[i]]++;
  		}
  		queue&lt;int&gt; q; 
  		vector&lt;int&gt; dp(n, 1);
  		for(int i = 0; i &lt; n; ++i) 
  			if(!d[i]) q.push(i);
  		while(SZ(q)) {
  			int u = q.front(); q.pop();
  			dp[a[u]] = max(dp[a[u]], dp[u]+1);
  			if(--d[a[u]] == 0) q.push(a[u]);
  		}
  		int ans = 0;
  		for(int i = 0; i &lt; n; ++i)
  			if(a[a[i]] == i) //两个之间互相喜欢，形成一个集合
  				ans += dp[i]+dp[a[i]];
 		ans /= 2; //计算了A, B和B, A两种情况，去重

  		//求最大环
  		vector&lt;int&gt; vis(n, 0);
  		for(int i = 0; i &lt; n; ++i) {
  			if(vis[i]) continue;
  			vector&lt;int&gt; b;
  			int x = i;
  			while(!vis[x]) { 
  				vis[x] = 1;
  				b.pb(x);
  				x = a[x];
  			}
  			for(int j = 0; j &lt; SZ(b); ++j)
  				if(b[j] == x)  //x是环上的点，也是与链的交点
  				ans = max(ans, SZ(b)-j);
  		}


  		return ans;	      
    }
}T;

void sol()
{
	vector&lt;int&gt; a{3,0,1,4,1};
	db1(T.maximumInvitations(a));
}
signed main()
{	
	//IOS
    //int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}
</code></pre>
<h1 id="d-keep-the-average-high"><a href="https://codeforces.com/contest/1616/problem/D">D. Keep the Average High</a></h1>
<p>思路：无脑dp，同时记录选择或不选的<strong>最大长度</strong>和<strong>最小sum(最坏情况)</strong></p>
<pre><code class="language-c++">﻿#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

int n, m;
int a[N];
int dp[N][2]; //选与不选的最大长度
int sum[N][2];//对应的最小sum
//te

void sol()
{
	int x;
	cin&gt;&gt;n;
	for(int i = 1; i &lt;= n; ++i) cin&gt;&gt;a[i];
	cin&gt;&gt;x;
	for(int i = 1; i &lt;= n; ++i) a[i] -= x;
	dp[1][0] = 0;
	dp[1][1] = 1;
	sum[1][0] = 0;
	sum[1][1] = a[1];

	for(int i = 2;i &lt;= n; ++i) {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
		sum[i][0] = 0;

		dp[i][1] = dp[i-1][0]+1;
		sum[i][1] = a[i];
		if(dp[i][1] &lt; dp[i-1][1]+1&amp;&amp;sum[i-1][1]+a[i]&gt;=0) {
			dp[i][1] = dp[i-1][1]+1;
			sum[i][1] = min(sum[i-1][1]+a[i], a[i]);
		}

	}
	//gg;
	//for(int i = 1; i &lt;= n; ++i) db2(dp[i][0], dp[i][1]);
	cout&lt;&lt;max(dp[n][0], dp[n][1])&lt;&lt;endl;
}
signed main()
{	
	IOS
    int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux基础课]]></title>
        <id>https://zzulihrs.github.io/post/linux-ji-chu-ke/</id>
        <link href="https://zzulihrs.github.io/post/linux-ji-chu-ke/">
        </link>
        <updated>2022-01-02T01:50:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-常用文件管理命令">1. 常用文件管理命令</h1>
<ol>
<li>
<h3 id="常用命令介绍">常用命令介绍</h3>
</li>
</ol>
<pre><code class="language-txt">(1) ctrl c: 取消命令，并且换行
(2) ctrl u: 清空本行命令
(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项
(4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件
(5) pwd: 显示当前路径
(6) cd XXX: 进入XXX目录下, cd .. 返回上层目录
(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt
(8) mkdir XXX: 创建目录XXX
(9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹
(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令
(11) touch XXX: 创建一个文件
(12) cat XXX: 展示文件XXX中的内容
(13) 复制文本
windows/Linux下：Ctrl + insert，Mac下：command + c
(14) 粘贴文本
windows/Linux下：Shift + insert，Mac下：command + v
</code></pre>
<ol start="2">
<li>创建作业 &amp; 测试作业的正确性</li>
</ol>
<pre><code class="language-txt">homework 1 create 可以重新创建所有lesson_1的作业
homework 1 create id 可以单独创建lesson_1的第id个作业. e.g.
homework 1 create 0 可以只重新创建lesson_1的第0个作业
homework 1 test 可以评测lesson_1的所有作业
</code></pre>
<ol start="3">
<li>作业</li>
</ol>
<pre><code class="language-txt">创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：
(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c
(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak
(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt
(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下
(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除
(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除
(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作
(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，
将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt;
将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt;
将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;
(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作
(9) 进入homework_9文件夹，将其中所有txt类型的文件删除
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://zzulihrs.github.io/post/shu-ju-ku-ji-chu/</id>
        <link href="https://zzulihrs.github.io/post/shu-ju-ku-ji-chu/">
        </link>
        <updated>2022-01-01T07:03:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1NJ411J79W">狂神说</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[algorithm]]></title>
        <id>https://zzulihrs.github.io/post/test/</id>
        <link href="https://zzulihrs.github.io/post/test/">
        </link>
        <updated>2021-12-28T12:32:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
]]></content>
    </entry>
</feed>