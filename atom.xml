<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzulihrs.github.io</id>
    <title>blog</title>
    <updated>2022-01-03T08:50:55.881Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzulihrs.github.io"/>
    <link rel="self" href="https://zzulihrs.github.io/atom.xml"/>
    <subtitle>fw</subtitle>
    <logo>https://zzulihrs.github.io/images/avatar.png</logo>
    <icon>https://zzulihrs.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, blog</rights>
    <entry>
        <title type="html"><![CDATA[随便写写题]]></title>
        <id>https://zzulihrs.github.io/post/sui-bian-xie-xie-ti/</id>
        <link href="https://zzulihrs.github.io/post/sui-bian-xie-xie-ti/">
        </link>
        <updated>2022-01-02T07:11:11.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h1 id="20220102">2022/01/02</h1>
<h2 id="5970-参加会议的最多员工数"><strong><a href="https://leetcode-cn.com/contest/weekly-contest-274/problems/maximum-employees-to-be-invited-to-a-meeting/">5970. 参加会议的最多员工数</a></strong></h2>
<p>leetcode第274周赛D题</p>
<p>挺有意思的题</p>
<p>思路：</p>
<p>两种情况</p>
<p>1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况</p>
<p>2）最大环，只能放一个</p>
<p>取两种情况的最大值</p>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

class Solution {
public:
	#define maxsize 100010
	#define pb push_back
	#define fi first
	#define se second
	#define SZ(x) (int)x.size()
	#define ALL(x) x.begin(), x.end()
	/*
	两种情况
	1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况
	2）最大环，只能放一个
	取两种情况的最大值
	*/

	vector&lt;int&gt; e[maxsize], re[maxsize];
	int d[maxsize];

    int maximumInvitations(vector&lt;int&gt;&amp; a) {
    	int n = SZ(a);

  		for(int i = 0; i &lt; SZ(a); ++i)
  		{
  			e[i].pb(a[i]);
  			re[a[i]].pb(i);
  			d[a[i]]++;
  		}
  		queue&lt;int&gt; q; 
  		vector&lt;int&gt; dp(n, 1);
  		for(int i = 0; i &lt; n; ++i) 
  			if(!d[i]) q.push(i);
  		while(SZ(q)) {
  			int u = q.front(); q.pop();
  			dp[a[u]] = max(dp[a[u]], dp[u]+1);
  			if(--d[a[u]] == 0) q.push(a[u]);
  		}
  		int ans = 0;
  		for(int i = 0; i &lt; n; ++i)
  			if(a[a[i]] == i) //两个之间互相喜欢，形成一个集合
  				ans += dp[i]+dp[a[i]];
 		ans /= 2; //计算了A, B和B, A两种情况，去重

  		//求最大环
  		vector&lt;int&gt; vis(n, 0);
  		for(int i = 0; i &lt; n; ++i) {
  			if(vis[i]) continue;
  			vector&lt;int&gt; b;
  			int x = i;
  			while(!vis[x]) { 
  				vis[x] = 1;
  				b.pb(x);
  				x = a[x];
  			}
  			for(int j = 0; j &lt; SZ(b); ++j)
  				if(b[j] == x)  //x是环上的点，也是与链的交点
  				ans = max(ans, SZ(b)-j);
  		}


  		return ans;	      
    }
}T;

void sol()
{
	vector&lt;int&gt; a{3,0,1,4,1};
	db1(T.maximumInvitations(a));
}
signed main()
{	
	//IOS
    //int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}
</code></pre>
<h1 id="d-keep-the-average-high"><strong><a href="https://codeforces.com/contest/1616/problem/D">D. Keep the Average High</a></strong></h1>
<p>思路：无脑dp，同时记录选择或不选的<strong><strong>最大长度</strong></strong>和<strong><strong>最小sum(最坏情况)</strong></strong></p>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

int n, m;
int a[N];
int dp[N][2]; //选与不选的最大长度
int sum[N][2];//对应的最小sum
//te

void sol()
{
	int x;
	cin&gt;&gt;n;
	for(int i = 1; i &lt;= n; ++i) cin&gt;&gt;a[i];
	cin&gt;&gt;x;
	for(int i = 1; i &lt;= n; ++i) a[i] -= x;
	dp[1][0] = 0;
	dp[1][1] = 1;
	sum[1][0] = 0;
	sum[1][1] = a[1];

	for(int i = 2;i &lt;= n; ++i) {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
		sum[i][0] = 0;

		dp[i][1] = dp[i-1][0]+1;
		sum[i][1] = a[i];
		if(dp[i][1] &lt; dp[i-1][1]+1&amp;&amp;sum[i-1][1]+a[i]&gt;=0) {
			dp[i][1] = dp[i-1][1]+1;
			sum[i][1] = min(sum[i-1][1]+a[i], a[i]);
		}

	}
	//gg;
	//for(int i = 1; i &lt;= n; ++i) db2(dp[i][0], dp[i][1]);
	cout&lt;&lt;max(dp[n][0], dp[n][1])&lt;&lt;endl;
}
signed main()
{	
	IOS
    int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}

</code></pre>
<h1 id="20220103">2022/01/03</h1>
<h2 id="d-shuffle"><strong><a href="https://codeforces.com/problemset/problem/1622/D">D. Shuffle</a></strong></h2>
<p>题意：对01串进行操作：取其中1的个数为k的连续子串，将这个子串重新排列。问至少一次操作后的01串有多少种情况</p>
<p>思路：</p>
<pre><code class="language-txt">pos记录每个1的位置
1和0的排列可以转换成小球放盒问题，m个1，n个0，等价于m+1个不同盒子，n个相同球的排列数
如何计算所有排列
以7 2  1100110为例

+1100的排列数
+1001的排列数 - 100的排列数，这是1100与1001之间的重复
以此类推
+00110的排列数 - 001的排列数
</code></pre>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 5100;
const int mod = 998244353;

ll fac[N], inv[N];

ll ksm(ll x, ll y)
{
	ll ans = 1;
	while(y)
	{
		if(y&amp;1) ans = ans*x%mod;
		x = x*x%mod;
		y &gt;&gt;= 1;
	}
	return ans;
}
void init()
{
	fac[0] = inv[0] = 1;
	for(int i = 1; i &lt;= 10000; ++i) fac[i] = fac[i-1]*i%mod;
	inv[10000] = ksm(fac[10000], mod-2);
	for(int i = 10000; i &gt;= 1; --i) inv[i-1] = inv[i]*i%mod;
}
ll C(int n, int m)
{
	return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
ll calc(int m, int n)//m个不同盒子，n个相同小球的排列数
{
	return C(m+n-1, m-1);
}
int a[M];

vector&lt;int&gt; pos;
bool vis[M];

void sol()
{
	int n, k;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%1d&quot;, &amp;a[i]);
	for(int i = 1; i &lt;= n; ++i)
		if(a[i]) pos.pb(i);
	
	if(SZ(pos) &lt; k||k==0) {
		puts(&quot;1&quot;);
		return ;
	}

	ll ans = 0;
	int l = 1, r = n;
	pos.pb(n+1);
	for(int i = k-1; i+1 &lt; SZ(pos); i++) {
		r = pos[i+1]-1;
		//db2(l, r);
		ans = (ans+calc(k+1, r-l-k+1))%mod;
 		if(i!=k-1) //第一个区间不用去重
		ans = (ans-calc(k, pos[i]-1-l-(k-1)+1)+mod)%mod; //去重，与前一个区间重复
		//重复的是(l, pos[i]-1)区间，里面有k-1个1
		l = pos[i-k+1]+1;
	}
	printf(&quot;%I64d\n&quot;, ans);
}
signed main()
{	
	init();
        sol();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux基础课]]></title>
        <id>https://zzulihrs.github.io/post/linux-ji-chu-ke/</id>
        <link href="https://zzulihrs.github.io/post/linux-ji-chu-ke/">
        </link>
        <updated>2022-01-02T01:50:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-常用文件管理命令">1. 常用文件管理命令</h1>
<ol>
<li>
<h3 id="常用命令介绍">常用命令介绍</h3>
</li>
</ol>
<pre><code class="language-txt">(1) ctrl c: 取消命令，并且换行
(2) ctrl u: 清空本行命令
(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项
(4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件
(5) pwd: 显示当前路径
(6) cd XXX: 进入XXX目录下, cd .. 返回上层目录
(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt
(8) mkdir XXX: 创建目录XXX
(9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹
(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令
(11) touch XXX: 创建一个文件
(12) cat XXX: 展示文件XXX中的内容
(13) 复制文本
windows/Linux下：Ctrl + insert，Mac下：command + c
(14) 粘贴文本
windows/Linux下：Shift + insert，Mac下：command + v
</code></pre>
<ol start="2">
<li>创建作业 &amp; 测试作业的正确性</li>
</ol>
<pre><code class="language-txt">homework 1 create 可以重新创建所有lesson_1的作业
homework 1 create id 可以单独创建lesson_1的第id个作业. e.g.
homework 1 create 0 可以只重新创建lesson_1的第0个作业
homework 1 test 可以评测lesson_1的所有作业
</code></pre>
<ol start="3">
<li>作业</li>
</ol>
<pre><code class="language-txt">创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：
(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c
(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak
(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt
(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下
(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除
(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除
(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作
(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，
将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt;
将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt;
将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;
(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作
(9) 进入homework_9文件夹，将其中所有txt类型的文件删除
</code></pre>
<h1 id="2-tmux和vim">2. tmux和vim</h1>
<ol>
<li>tmux教程</li>
</ol>
<pre><code class="language-txt">功能：
    (1) 分屏。
    (2) 允许断开Terminal连接后，继续运行进程。
结构：
    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。
    实例：
        tmux:
            session 0:
                window 0:
                    pane 0
                    pane 1
                    pane 2
                    ...
                window 1
                window 2
                ...
            session 1
            session 2
            ...
操作：
    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。
    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。
    (3) 按下Ctrl + a后手指松开，然后按&quot;（注意是双引号&quot;）：将当前pane上下平分成两个pane。
    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。
    (5) 鼠标点击可以选pane。
    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。
    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。
    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。
    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。
    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。
    (11) tmux a：打开之前挂起的session。
    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。
        方向键 —— 上：选择上一项 session/window/pane
        方向键 —— 下：选择下一项 session/window/pane
        方向键 —— 右：展开当前项 session/window
        方向键 —— 左：闭合当前项 session/window
    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。
    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。
    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。
    (16) 鼠标滚轮：翻阅当前pane内的内容。
    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）
    (18) tmux中复制/粘贴文本的通用方式：
        (1) 按下Ctrl + a后松开手指，然后按[
        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板
        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处
</code></pre>
<ol start="2">
<li>vim教程</li>
</ol>
<pre><code class="language-txt">功能：
    (1) 命令行模式下的文本编辑器。
    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。
    (3) 使用方式：vim filename
        如果已有该文件，则打开它。
        如果没有该文件，则打开个一个新的文件，并命名为filename
模式：
    (1) 一般命令模式
        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。
    (2) 编辑模式
        在一般命令模式里按下i，会进入编辑模式。
        按下ESC会退出编辑模式，返回到一般命令模式。
    (3) 命令行模式
        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。
        可以查找、替换、保存、退出、配置编辑器等。
操作：
    (1) i：进入编辑模式
    (2) ESC：进入一般命令模式
    (3) h 或 左箭头键：光标向左移动一个字符
    (4) j 或 向下箭头：光标向下移动一个字符
    (5) k 或 向上箭头：光标向上移动一个字符
    (6) l 或 向右箭头：光标向右移动一个字符
    (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符
    (8) 0 或 功能键[Home]：光标移动到本行开头
    (9) $ 或 功能键[End]：光标移动到本行末尾
    (10) G：光标移动到最后一行
    (11) :n 或 nG：n为数字，光标移动到第n行
    (12) gg：光标移动到第一行，相当于1G
    (13) n&lt;Enter&gt;：n为数字，光标向下移动n行
    (14) /word：向光标之下寻找第一个值为word的字符串。
    (15) ?word：向光标之上寻找第一个值为word的字符串。
    (16) n：重复前一个查找操作
    (17) N：反向重复前一个查找操作
    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2
    (19) :1,$s/word1/word2/g：将全文的word1替换为word2
    (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。
    (21) v：选中文本
    (22) d：删除选中的文本
    (23) dd: 删除当前行
    (24) y：复制选中的文本
    (25) yy: 复制当前行
    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴
    (27) u：撤销
    (28) Ctrl + r：取消撤销
    (29) 大于号 &gt;：将选中的文本整体向右缩进一次
    (30) 小于号 &lt;：将选中的文本整体向左缩进一次
    (31) :w 保存
    (32) :w! 强制保存
    (33) :q 退出
    (34) :q! 强制退出
    (35) :wq 保存并退出
    (36) :set paste 设置成粘贴模式，取消代码自动缩进
    (37) :set nopaste 取消粘贴模式，开启代码自动缩进
    (38) :set nu 显示行号
    (39) :set nonu 隐藏行号
    (40) gg=G：将全文代码格式化
    (41) :noh 关闭查找关键词高亮
    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令
    (43) Ctrl+z：后台挂起当前进程，通过fg+id可以恢复
异常处理：
    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。
    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：
        (1) 找到正在打开该文件的程序，并退出
        (2) 直接删掉该swp文件即可
</code></pre>
<ol start="3">
<li>创建作业 &amp; 测试作业的正确性</li>
</ol>
<pre><code class="language-txt">homework 2 create 可以重新创建所有lesson_2的作业。
homework 2 create id 可以单独创建lesson_2的第id个作业. e.g.
    homework 2 create 0 可以只重新创建lesson_2的第0个作业
homework 2 test 可以评测lesson_2的所有作业
</code></pre>
<ol start="4">
<li>作业</li>
</ol>
<pre><code class="language-txt">创建好作业后，先进入文件夹/home/acs/homework/lesson_2/，然后：
(0) 进入homework_0文件夹，创建文件names.txt，并顺次将下列姓名写入该文件，每个名字占一行。
    AcWing、yxc、Bob、张强、李明、Alice
(1) 进入homework_1文件夹，打开problem.txt，并依次删除下列字符：
    [1] 最后一行第101个字符
    [2] 第3行第8个字符
    [3] 第1行第30个字符
    [4] 第16行第55个字符
    [5] 第9行第80个字符
    最后保存文件并退出。
(2) 进入homework_2文件夹，打开problem.txt，并依次执行如下操作：
    [1] 在第1个&quot;two&quot;的后面添加&quot;abc&quot;
    [2] 在第2个&quot;two&quot;的前面添加&quot;def&quot;
    [3] 将第3个&quot;two&quot;后面的连续12个字符删掉
    [4] 将第4个&quot;two&quot;所在的行删掉
    最后保存文件并退出。
(3) 进入homework_3文件夹，打开problem.txt，并依次执行如下操作：
    [1] 将第5行至第15行中所有of替换成OF。
    [2] 将全文中所有的the替换成THE。
    [3] 将第偶数个is替换成IS，第奇数个is不变。下标从1开始。
(4) 进入homework_4文件夹，打开problem.txt，并依次执行如下操作：
    [1] 删除第11行
    [2] 将所删除的行粘贴到文件最后一行的下一行
    [3] 复制第5行
    [4] 将所复制的行粘贴到文件当前最后一行的下一行
(5) 进入homework_5文件夹，打开problem.txt，并依次执行如下操作：
    [1] 删除第11行第15个字符（包含该字符）至第13行第5个字符（包含该字符）
    [2] 将所删除的内容粘贴到文件末尾（注意不要另起一行）
    [3] 复制第5行第88个字符（包含该字符）至第7行第6个字符（包含该字符）
    [4] 将所复制的内容粘贴到当前文件末尾（注意不要另起一行）
(6) 进入homework_6文件夹，并依次执行如下操作：
    [1] 清空source0.cpp
    [2] 将source1.cpp中的第1-3行和第12-24行复制到source0.cpp中
(7) 进入homework_7文件夹，格式化source.cpp
(8) 进入homework_8文件夹，打开source.cpp，并依次执行如下操作：
    [1] 将第15-21行向右缩进2次。
    [2] 将第22-23行向左缩进1次。
(9) 进入homework_9文件夹，打开链接：https://www.acwing.com/activity/content/code/content/1694465/
    新建文件source.cpp，将链接中的代码抄进source.cpp文件中。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://zzulihrs.github.io/post/shu-ju-ku-ji-chu/</id>
        <link href="https://zzulihrs.github.io/post/shu-ju-ku-ji-chu/">
        </link>
        <updated>2022-01-01T07:03:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1NJ411J79W">狂神说</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[algorithm]]></title>
        <id>https://zzulihrs.github.io/post/test/</id>
        <link href="https://zzulihrs.github.io/post/test/">
        </link>
        <updated>2021-12-28T12:32:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
]]></content>
    </entry>
</feed>