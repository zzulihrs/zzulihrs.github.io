<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzulihrs.github.io</id>
    <title>blog</title>
    <updated>2023-02-25T08:07:54.766Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzulihrs.github.io"/>
    <link rel="self" href="https://zzulihrs.github.io/atom.xml"/>
    <subtitle>fw</subtitle>
    <logo>https://zzulihrs.github.io/images/avatar.png</logo>
    <icon>https://zzulihrs.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, blog</rights>
    <entry>
        <title type="html"><![CDATA[py基础]]></title>
        <id>https://zzulihrs.github.io/post/py-ji-chu/</id>
        <link href="https://zzulihrs.github.io/post/py-ji-chu/">
        </link>
        <updated>2023-02-24T06:44:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pip">pip</h2>
<ul>
<li>pip install 安装包</li>
<li>pip uninstall 删除</li>
<li>pip list 显示已经安装的包</li>
<li>pip freeze 显示已经安装的包，并且以指定的格式显示<br>
修改pip下载源<br>
pip install 包名 -i 国内源(https://pypi.douban.com/simple/)</li>
</ul>
<p>单行注释'#'<br>
多行注释'''<br>
pycharm破解https://www.cnblogs.com/Dengv5/p/16418279.html<br>
pycharm选择2022.1.3专业版</p>
<p>强制类型转换<br>
int()<br>
str()#转成字符串<br>
type()#变量类型</p>
<p>//取整除<br>
**指数</p>
<p>多个变量赋值<br>
a, b, c = 1, 2, 3</p>
<p>输入输出格式<br>
passwork = input()<br>
print('我的名字是%s, 我的年龄是%d' % (name, age))</p>
<p>循环<br>
for i in rang(1, 5，3) 左闭右开[1, 5)， 3是步长</p>
<p>字符串处理<br>
获取长度：len(s)<br>
查找指定内容在字符串中是否出现：find()<br>
判断是否是什么开头/结尾：startswith,endswith<br>
计算出现次数: count()<br>
替换内容：replace()<br>
切割字符串：split()<br>
修改大小写：upper(), lower()<br>
空格处理：strip(), 去空格<br>
字符串拼接：join()</p>
<h2 id="列表增删改查">列表增删改查</h2>
<p>append()在末尾添加元素<br>
insert(index, str)在指定位置插入元素, index是插入位置<br>
extend()合并两个列表<br>
查找<br>
in 和 not in<br>
删除<br>
del arr[index] 根据下标进行删除<br>
pop()删除最后一个元素<br>
remove根据元素的值进行删除</p>
<p>定义只有一个元素的元组，需要在唯一的元素后加一个逗号<br>
a_tuple = (5, )</p>
<p>切片：[起始:终止:步长]，也可以不加步长<br>
可以[起始:] 或者[:终止]</p>
<h2 id="字典增删改查">字典增删改查</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[租云服务器及配docker环境]]></title>
        <id>https://zzulihrs.github.io/post/zu-yun-fu-wu-qi-ji-pei-docker-huan-jing/</id>
        <link href="https://zzulihrs.github.io/post/zu-yun-fu-wu-qi-ji-pei-docker-huan-jing/">
        </link>
        <updated>2022-01-18T16:50:03.000Z</updated>
        <content type="html"><![CDATA[<p>阿里云地址：https://www.aliyun.com/</p>
<p>创建工作用户acs并赋予sudo权限<br>
登录到新服务器。打开AC Terminal，然后：</p>
<p>ssh root@xxx.xxx.xxx.xxx  # xxx.xxx.xxx.xxx替换成新服务器的公网IP<br>
创建acs用户：</p>
<p>adduser acs  # 创建用户acs<br>
usermod -aG sudo acs  # 给用户acs分配sudo权限<br>
配置免密登录方式<br>
退回AC Terminal，然后配置acs用户的别名和免密登录，可以参考4. ssh——ssh登录。</p>
<p>配置新服务器的工作环境<br>
将AC Terminal的配置传到新服务器上：</p>
<p>scp .bashrc .vimrc .tmux.conf server_name:  # server_name需要换成自己配置的别名<br>
安装tmux和docker<br>
登录自己的服务器，然后安装tmux：</p>
<p>sudo apt-get update<br>
sudo apt-get install tmux<br>
打开tmux。（养成好习惯，所有工作都在tmux里进行，防止意外关闭终端后，工作进度丢失）</p>
<p>然后在tmux中根据docker安装教程安装docker即可。</p>
<p><strong>docker教程</strong><br>
将当前用户添加到docker用户组<br>
为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组(可以参考官方文档)：</p>
<p>sudo usermod -aG docker $USER<br>
镜像（images）<br>
docker pull ubuntu:20.04：拉取一个镜像<br>
docker images：列出本地所有镜像<br>
docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04<br>
docker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像<br>
docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中<br>
docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来<br>
容器(container)<br>
docker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。<br>
docker ps -a：查看本地的所有容器<br>
docker [container] start CONTAINER：启动容器<br>
docker [container] stop CONTAINER：停止容器<br>
docker [container] restart CONTAINER：重启容器<br>
docker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器<br>
docker [container] attach CONTAINER：进入容器<br>
先按Ctrl-p，再按Ctrl-q可以挂起容器<br>
docker [container] exec CONTAINER COMMAND：在容器中执行命令<br>
docker [container] rm CONTAINER：删除容器<br>
docker container prune：删除所有已停止的容器<br>
docker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中<br>
docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag<br>
docker export/import与docker save/load的区别：<br>
export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态<br>
save/load会保存完整记录，体积更大<br>
docker top CONTAINER：查看某个容器内的所有进程<br>
docker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息<br>
docker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx：在本地和容器间复制文件<br>
docker rename CONTAINER1 CONTAINER2：重命名容器<br>
docker update CONTAINER --memory 500MB：修改容器限制<br>
实战<br>
进入AC Terminal，然后：</p>
<p>scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器<br>
ssh server_name  # 登录自己的云端服务器</p>
<p>docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地<br>
docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像</p>
<p>docker attach my_docker_server  # 进入创建的docker容器<br>
passwd  # 设置root密码<br>
去云平台控制台中修改安全组配置，放行端口20000。</p>
<p>返回AC Terminal，即可通过ssh登录自己的docker容器：</p>
<p>ssh root@xxx.xxx.xxx.xxx -p 20000  # 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址<br>
然后，可以仿照上节课内容，创建工作账户acs。</p>
<p>最后，可以参考4. ssh——ssh登录配置docker容器的别名和免密登录。</p>
<p>小Tips<br>
如果apt-get下载软件速度较慢，可以参考清华大学开源软件镜像站中的内容，修改软件源。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[管道、环境变量与常用命令]]></title>
        <id>https://zzulihrs.github.io/post/guan-dao-huan-jing-bian-liang-yu-chang-yong-ming-ling/</id>
        <link href="https://zzulihrs.github.io/post/guan-dao-huan-jing-bian-liang-yu-chang-yong-ming-ling/">
        </link>
        <updated>2022-01-17T06:18:15.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>管道</strong><br>
概念<br>
管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。<br>
<code>|</code>就是管道，从一边流向另外一边<br>
要点<br>
管道命令仅处理stdout，会忽略stderr。<br>
管道右边的命令必须能接受stdin。<br>
多个管道命令可以串联。<br>
与文件重定向的区别<br>
文件重定向左边为命令，右边为文件。<br>
管道左右两边均为命令，左边有stdout，右边有stdin。<br>
举例<br>
统计当前目录下所有python文件的总行数，其中find、xargs、wc等命令可以参考常用命令这一节内容。</li>
</ol>
<p>find . -name '*.py' | xargs cat | wc -l</p>
<ol start="2">
<li><strong>环境变量</strong><br>
概念<br>
Linux系统中会用很多环境变量来记录配置信息。<br>
环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</li>
</ol>
<p>查看<br>
列出当前环境下的所有环境变量：</p>
<p>env  # 显示当前用户的变量<br>
set  # 显示当前shell的变量，包括当前用户的变量;<br>
export  # 显示当前导出成用户变量的shell变量<br>
输出某个环境变量的值：</p>
<p>echo $PATH<br>
修改<br>
环境变量的定义、修改、删除操作可以参考3. shell语法——变量这一节的内容。</p>
<p>为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到~/.bashrc文件中。<br>
修改完~/.bashrc文件后，记得执行source ~/.bashrc，来将修改应用到当前的bash环境下。</p>
<p>为何将修改命令放到~/.bashrc，就可以确保修改会影响未来所有的环境呢？</p>
<p>每次启动bash，都会先执行~/.bashrc。<br>
每次ssh登陆远程服务器，都会启动一个bash命令行给我们。<br>
每次tmux新开一个pane，都会启动一个bash命令行给我们。<br>
所以未来所有新开的环境都会加载我们修改的内容。<br>
常见环境变量<br>
<code>HOME</code>：用户的家目录。<br>
<code>PATH</code>：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。<br>
<code>LD_LIBRARY_PATH</code>：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。<br>
<code>C_INCLUDE_PATH</code>：C语言的头文件路径，内容是以冒号分隔的路径列表。<br>
<code>CPLUS_INCLUDE_PATH</code>：CPP的头文件路径，内容是以冒号分隔的路径列表。<br>
<code>PYTHONPATH</code>：Python导入包的路径，内容是以冒号分隔的路径列表。<br>
<code>JAVA_HOME</code>：jdk的安装目录。<br>
<code>CLASSPATH</code>：存放Java导入类的路径，内容是以冒号分隔的路径列表</p>
<ol start="3">
<li><strong>常用命令</strong></li>
</ol>
<p>Linux命令非常多，本节讲解几个常用命令。其他命令依赖于大家根据实际操作环境，边用边查。</p>
<p>系统状况<br>
top：查看所有进程的信息（Linux的任务管理器）<br>
打开后，输入M：按使用内存排序<br>
打开后，输入P：按使用CPU排序<br>
打开后，输入q：退出<br>
df -h：查看硬盘使用情况<br>
free -h：查看内存使用情况<br>
du -sh：查看当前目录占用的硬盘空间<br>
ps aux：查看所有进程<br>
kill -9 pid：杀死编号为pid的进程<br>
传递某个具体的信号：kill -s SIGTERM pid<br>
netstat -nt：查看所有网络连接<br>
w：列出当前登陆的用户<br>
ping www.baidu.com：检查是否连网<br>
文件权限<br>
chmod：修改文件权限<br>
chmod +x xxx：给xxx添加可执行权限<br>
chmod -x xxx：去掉xxx的可执行权限<br>
chmod 777 xxx：将xxx的权限改成777<br>
chmod 777 xxx -R：递归修改整个文件夹的权限<br>
文件检索<br>
find /path/to/directory/ -name '<em>.py'：搜索某个文件路径下的所有</em>.py文件<br>
grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。<br>
wc：统计行数、单词数、字节数<br>
既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；<br>
wc -l：统计行数<br>
wc -w：统计单词数<br>
wc -c：统计字节数<br>
tree：展示当前目录的文件结构<br>
tree /path/to/directory/：展示某个目录的文件结构<br>
tree -a：展示隐藏文件<br>
ag xxx：搜索当前目录下的所有文件，检索xxx字符串<br>
cut：分割一行内容<br>
从stdin中读入多行数据<br>
echo $PATH | cut -d ':' -f 3,5：输出PATH用:分割后第3、5列数据<br>
echo $PATH | cut -d ':' -f 3-5：输出PATH用:分割后第3-5列数据<br>
echo $PATH | cut -c 3,5：输出PATH的第3、5个字符<br>
echo $PATH | cut -c 3-5：输出PATH的第3-5个字符<br>
sort：将每行内容按字典序排序<br>
可以从stdin中读取多行数据<br>
可以从命令行参数中读取文件名列表<br>
xargs：将stdin中的数据用空格或回车分割成命令行参数<br>
find . -name '<em>.py' | xargs cat | wc -l：统计当前目录下所有python文件的总行数<br>
查看文件内容<br>
more：浏览文件内容<br>
回车：下一行<br>
空格：下一页<br>
b：上一页<br>
q：退出<br>
less：与more类似，功能更全<br>
回车：下一行<br>
y：上一行<br>
Page Down：下一页<br>
Page Up：上一页<br>
q：退出<br>
head -3 xxx：展示xxx的前3行内容<br>
同时支持从stdin读入内容<br>
tail -3 xxx：展示xxx末尾3行内容<br>
同时支持从stdin读入内容<br>
用户相关<br>
history：展示当前用户的历史操作。内容存放在~/.bash_history中<br>
工具<br>
md5sum：计算md5哈希值<br>
可以从stdin读入内容<br>
也可以在命令行参数中传入文件名列表；<br>
time command：统计command命令的执行时间<br>
ipython3：交互式python3环境。可以当做计算器，或者批量管理文件。<br>
! echo &quot;Hello World&quot;：!表示执行shell脚本<br>
watch -n 0.1 command：每0.1秒执行一次command命令<br>
tar：压缩文件<br>
tar -zcvf xxx.tar.gz /path/to/file/</em>：压缩<br>
tar -zxvf xxx.tar.gz：解压缩<br>
diff xxx yyy：查找文件xxx与yyy的不同点<br>
安装软件<br>
sudo command：以root身份执行command命令<br>
apt-get install xxx：安装软件<br>
pip install xxx --user --upgrade：安装python包</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ git]]></title>
        <id>https://zzulihrs.github.io/post/git/</id>
        <link href="https://zzulihrs.github.io/post/git/">
        </link>
        <updated>2022-01-08T13:06:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-git教程">1. git教程</h1>
<p>代码托管平台：<a href="git.acwing.com">git.acwing.com</a></p>
<h2 id="11-git基本概念">1.1. git基本概念</h2>
<p>工作区：仓库的目录。工作区是独立于各个分支的。<br>
暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。<br>
版本库：存放所有已经提交到本地仓库的代码版本<br>
版本结构：树结构，树中每个节点代表一个代码版本。</p>
<h2 id="12-git常用命令">1.2 git常用命令</h2>
<ol>
<li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</li>
<li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/ .gitconfig</code>文件中</li>
<li><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中</li>
<li><code>git add XX</code>：将XX文件添加到暂存区</li>
<li><code>git add</code> .：将所有待加入暂存区的文件加入暂存区</li>
<li><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</li>
<li><code>git commit -m</code> &quot;给自己看的备注信息&quot;：将暂存区的内容提交到当前分支</li>
<li><code>git status</code>：查看仓库状态</li>
<li><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</li>
<li><code>git log</code>：查看当前分支的所有版本</li>
<li><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</li>
<li><code>git reset --hard HEAD^</code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li>
<li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li>
<li><code>git reset --hard</code> 版本号：回滚到某一特定版本</li>
<li><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</li>
<li><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓</li>
<li><code>git push -u</code>(第一次需要-u以后不需要)：将当前分支推送到远程仓库</li>
<li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li>
<li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li>
<li><code>git checkout -b branch_name</code>：创建并切换到<code>branch_name</code>这个分支</li>
<li><code>git branch</code>：查看所有分支和当前所处分支</li>
<li><code>git checkout branch_name</code>：切换到<code>branch_name</code>这个分支</li>
<li><code>git merge branch_name</code>：将分支<code>branch_name</code>合并到当前分支上</li>
<li><code>git branch -d branch_name</code>：删除本地仓库的<code>branch_name</code>分支</li>
<li><code>git branch branch_name</code>：创建新分支</li>
<li><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</li>
<li><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</li>
<li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</li>
<li><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</li>
<li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</li>
<li><code>git checkout -t origin/branch_name</code> 将远程的<code>branch_name</code>分支拉取到本地</li>
<li><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</li>
<li><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li>
<li><code>git stash drop</code>：删除栈顶存储的修改</li>
<li><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li>
<li><code>git stash list</code>：查看栈中所有元素</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ssh]]></title>
        <id>https://zzulihrs.github.io/post/ssh/</id>
        <link href="https://zzulihrs.github.io/post/ssh/">
        </link>
        <updated>2022-01-06T12:47:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ssh登录">ssh登录</h1>
<p><strong>基本用法</strong><br>
远程登录服务器：</p>
<pre><code class="language-shell">ssh user@hostname
</code></pre>
<ul>
<li><code>user</code>: 用户名</li>
<li><code>hostname</code>: IP地址或域名<br>
第一次登录时会提示：</li>
</ul>
<pre><code class="language-shell">The authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.
ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</code></pre>
<p>输入<code>yes</code>，然后回车即可。<br>
这样会将该服务器的信息记录在<code>~/.ssh/known_hosts</code>文件中。</p>
<p>然后输入密码即可登录到远程服务器中。</p>
<p>默认登录端口号为22。如果想登录某一特定端口：</p>
<pre><code class="language-shell">ssh user@hostname -p 22
</code></pre>
<p><strong>配置文件</strong><br>
创建文件<code>~/.ssh/config</code>。</p>
<p>然后在文件中输入：</p>
<pre><code class="language-shell">Host myserver1
    HostName IP地址或域名
    User 用户名

Host myserver2
    HostName IP地址或域名
    User 用户名
</code></pre>
<p>之后再使用服务器时，可以直接使用别名<code>myserver1</code>、<code>myserver2</code>。<br>
<strong>密钥登录</strong><br>
创建密钥：</p>
<pre><code class="language-shell">ssh-keygen
</code></pre>
<p>然后一直回车即可。</p>
<p>执行结束后，<code>~/.ssh/</code>目录下会多两个文件：</p>
<p><code>id_rsa</code>：私钥<br>
<code>id_rsa.pub</code>：公钥<br>
之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p>
<p>例如，想免密登录<code>myserver</code>服务器。则将公钥中的内容，复制到<code>myserver</code>中的<code>~/.ssh/authorized_keys</code>文件里即可。</p>
<p>也可以使用如下命令一键添加公钥：</p>
<pre><code class="language-shell">ssh-copy-id myserver
</code></pre>
<p><strong>执行命令</strong><br>
命令格式：</p>
<pre><code class="language-shell">ssh user@hostname command
</code></pre>
<p>例如：</p>
<pre><code class="language-shell">ssh user@hostname ls -a
</code></pre>
<p>或者</p>
<pre><code class="language-shell"># 单引号中的$i可以求值
ssh myserver 'for ((i = 0; i &lt; 10; i ++ )) do echo $i; done'
</code></pre>
<p>或者</p>
<pre><code class="language-shell"># 双引号中的$i不可以求值
ssh myserver &quot;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&quot;
</code></pre>
<h1 id="scp传文件">scp传文件</h1>
<p><strong>基本用法</strong><br>
命令格式：</p>
<pre><code class="language-shelll">scp source destination
</code></pre>
<p>将<code>source</code>路径下的文件复制到<code>destination</code>中</p>
<p>一次复制多个文件：</p>
<pre><code class="language-shell">scp source1 source2 destination
</code></pre>
<p>复制文件夹：</p>
<pre><code class="language-shell">scp -r ~/tmp myserver:/home/acs/
</code></pre>
<p>将本地家目录中的<code>tmp</code>文件夹复制到<code>myserver</code>服务器中的<code>/home/acs/</code>目录下。</p>
<pre><code class="language-shell">scp -r ~/tmp myserver:homework/
</code></pre>
<p>将本地家目录中的<code>tmp</code>文件夹复制到<code>myserver</code>服务器中的<code>~/homework/</code>目录下。</p>
<pre><code class="language-shell">scp -r myserver:homework .
</code></pre>
<p>将<code>myserver</code>服务器中的<code>~/homework/</code>文件夹复制到本地的当前路径下。</p>
<p>指定服务器的端口号：</p>
<pre><code class="language-shell">scp -P 22 source1 source2 destination
</code></pre>
<p>注意： <code>scp</code>的<code>-r -P</code>等参数尽量加在<code>source</code>和<code>destination</code>之前。</p>
<p>⭐️使用scp配置其他服务器的<code>vim</code>和<code>tmux</code></p>
<pre><code class="language-shell">scp ~/.vimrc ~/.tmux.conf myserver:
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell语法]]></title>
        <id>https://zzulihrs.github.io/post/shell-yu-fa/</id>
        <link href="https://zzulihrs.github.io/post/shell-yu-fa/">
        </link>
        <updated>2022-01-03T14:15:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-shell%E8%AF%AD%E6%B3%95"><strong>1. shell语法</strong></a></li>
<li><a href="#2%E6%B3%A8%E9%87%8A"><strong>2.注释</strong></a></li>
<li><a href="#3%E5%8F%98%E9%87%8F"><strong>3.变量</strong></a></li>
<li><a href="#4-%E9%BB%98%E8%AE%A4%E5%8F%98%E9%87%8F"><strong>4. 默认变量</strong></a></li>
<li><a href="#5%E6%95%B0%E7%BB%84"><strong>5.数组</strong></a></li>
<li><a href="#6expr%E5%91%BD%E4%BB%A4"><strong>6.expr命令</strong></a></li>
<li><a href="#7read%E5%91%BD%E4%BB%A4"><strong>7.read命令</strong></a></li>
<li><a href="#8echo%E5%91%BD%E4%BB%A4"><strong>8.echo命令</strong></a></li>
<li><a href="#9printf%E5%91%BD%E4%BB%A4"><strong>9.printf命令</strong></a></li>
<li><a href="#10-test%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%88%A4%E6%96%AD%E7%AC%A6%E5%8F%B7"><strong>10. test命令与判断符号[]</strong></a></li>
<li><a href="#11%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><strong>11.判断语句</strong></a></li>
<li><a href="#12%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><strong>12.循环语句</strong></a></li>
<li><a href="#13%E5%87%BD%E6%95%B0"><strong>13.函数</strong></a></li>
<li><a href="#14exit%E5%91%BD%E4%BB%A4"><strong>14.exit命令</strong></a></li>
<li><a href="#15%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91"><strong>15.文件重定向</strong></a></li>
<li><a href="#16%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E8%84%9A%E6%9C%AC"><strong>16.引入外部脚本</strong></a></li>
</ul>
</p>
<p>笔记：<br>
1、定义变量时，等号两边不能有空格<br>
2、定义变量的时候变量都是字符串，但当变量需要是整数时，会自动把变量转换成整数<br>
3、type+命令可以解释该命令的来源（内嵌命令。第三方命令等）<br>
如type readonly #readonly is a shell builtin(shell内部命令)<br>
type ls # ls is aliased to ‘ls –color+auto’<br>
4、被声明为只读的变量无法被unset删除<br>
5、bash可以用来开一个新的进程，exit或Ctrl+d退出新的bash<br>
6、字符串中，不加引号和双引号效果相同<br>
7、区分<code>``和单引号'</code>在expr命令中的区别<br>
8、查看权限 'ls -l test.sh'</p>
<p>小技巧：如何将服务器中的文件整体复制出来？</p>
<ol>
<li>退出<code>tmux</code></li>
<li><code>cat filename</code>：展示<code>filename</code>的文件内容</li>
<li>鼠标选中文本开头的若干字符</li>
<li>用滚轮滑到文件结尾</li>
<li>按住<code>Shift</code>，同时鼠标点击文件结尾，此时会选中文件所有内容</li>
<li>Windows/Linux下，按<code>Ctrl + insert</code>可以复制全文；Mac下，按<code>Command + c</code>可以复制全文。</li>
</ol>
<h1 id="1-shell语法"><strong>1. shell语法</strong></h1>
<p><strong>概论</strong></p>
<p>shell是我们通过命令行与操作系统沟通的语言。</p>
<p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。</p>
<p>AC Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。</p>
<p>Linux中常见的shell脚本有很多种，常见的有：</p>
<ul>
<li>
<p>Bourne Shell(<code>/usr/bin/sh'或'/bin/sh</code>)</p>
</li>
<li>
<p>Bourne Again Shell(<code>/bin/bash</code>)</p>
</li>
<li>
<p>C Shell(<code>/usr/bin/csh</code>)</p>
</li>
<li>
<p>K Shell(<code>/usr/bin/ksh</code>)</p>
</li>
<li>
<p>zsh</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<p>Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。</p>
<p>文件开头需要写<code>#! /bin/bash</code>，指明bash为脚本解释器。</p>
<p>脚本示例<br>
新建一个<code>test.sh</code>文件，内容如下：</p>
<pre><code class="language-shell">#! /bin/bash
echo &quot;Hello World!&quot;
</code></pre>
<p><strong>学习技巧</strong></p>
<p>不要死记硬背，遇到含糊不清的地方，可以在AC Terminal里实际运行一遍。</p>
<p><strong>运行方式</strong></p>
<p>作为可执行文件</p>
<pre><code class="language-shell">
acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 使脚本具有可执行权限

acs@9e0ebfcd82d7:~$ ./test.sh  # 当前路径下执行

Hello World!  # 脚本输出

acs@9e0ebfcd82d7:~$ /home/acs/test.sh  # 绝对路径下执行

Hello World!  # 脚本输出

acs@9e0ebfcd82d7:~$ ~/test.sh  # 家目录路径下执行

Hello World!  # 脚本输出

</code></pre>
<p>用解释器执行</p>
<pre><code class="language-shell">
acs@9e0ebfcd82d7:~$ bash test.sh

Hello World!  # 脚本输出

</code></pre>
<h1 id="2注释"><strong>2.注释</strong></h1>
<p><strong>单行注释</strong></p>
<p>每行中<code>#</code>之后的内容均是注释。</p>
<pre><code class="language-shell">#这是一行注释

echo 'Hello World'  #  这也是注释
</code></pre>
<p><strong>多行注释</strong></p>
<p>格式：</p>
<pre><code class="language-shell">:&lt;&lt;EOF

第一行注释

第二行注释

第三行注释

EOF
</code></pre>
<p>其中<code>EOF</code>可以换成其它任意字符串。例如：</p>
<pre><code class="language-shell">:&lt;&lt;abc

第一行注释

第二行注释

第三行注释

abc



:&lt;&lt;!

第一行注释

第二行注释

第三行注释

!
</code></pre>
<h1 id="3变量"><strong>3.变量</strong></h1>
<p><strong>定义变量</strong></p>
<p>定义变量，不需要加<code>$</code>符号，例如：</p>
<pre><code class="language-shell">name1='yxc'  # 单引号定义字符串

name2=&quot;yxc&quot;  # 双引号定义字符串

name3=yxc    # 也可以不加引号，同样表示字符串
</code></pre>
<p><strong>使用变量</strong></p>
<p>使用变量，需要加上<code>$`符号，或者`${}</code>符号。花括号是可选的，主要为了帮助解释器识别变量边界。</p>
<pre><code class="language-shell">name=yxc
echo $name  # 输出yxc
echo ${name}  # 输出yxc
echo ${name}acwing  # 输出yxcacwing
</code></pre>
<p><strong>只读变量</strong><br>
使用readonly或者declare可以将变量变为只读。</p>
<pre><code class="language-shell">name=yxc
readonly name
declare -r name  # 两种写法均可

name=abc  # 会报错，因为此时name只读
</code></pre>
<p><strong>删除变量</strong></p>
<p><code>unset</code>可以删除变量。</p>
<pre><code class="language-shell">name=yxc
unset name
echo $name  # 输出空行
</code></pre>
<p>变量类型<br>
1. 自定义变量（局部变量）<br>
子进程不能访问的变量</p>
<ol start="2">
<li>
<p>环境变量（全局变量）<br>
子进程可以访问的变量</p>
<p>自定义变量改成环境变量：</p>
</li>
</ol>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ name=yxc  # 定义变量
acs@9e0ebfcd82d7:~$ export name  # 第一种方法
acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法
</code></pre>
<p>环境变量改为自定义变量：</p>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量
acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量
</code></pre>
<p><strong>字符串</strong></p>
<p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<p>单引号与双引号的区别：</p>
<ul>
<li>单引号中的内容会原样输出，不会执行、不会取变量；</li>
<li>双引号中的内容可以执行、可以取变量；</li>
</ul>
<pre><code class="language-shell">name=yxc  # 不用引号
echo 'hello, $name \&quot;hh\&quot;'  # 单引号字符串，输出 hello, $name \&quot;hh\&quot;
echo &quot;hello, $name \&quot;hh\&quot;&quot;  # 双引号字符串，输出 hello, yxc &quot;hh&quot;
</code></pre>
<p>获取字符串长度</p>
<pre><code class="language-shell">name=&quot;yxc&quot;
echo ${#name}  # 输出3
</code></pre>
<p>提取子串</p>
<pre><code class="language-shell">name=&quot;hello, yxc&quot;
echo ${name:0:5}  # 提取从0开始的5个字符
</code></pre>
<h1 id="4-默认变量"><strong>4. 默认变量</strong></h1>
<p><strong>文件参数变量</strong><br>
在执行shell脚本时，可以向脚本传递参数。<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，以此类推。特殊的，<code>$0</code>是文件名（包含路径）。例如：</p>
<p>创建文件<code>test.sh</code>：</p>
<pre><code class="language-shell">#! /bin/bash

echo &quot;文件名：&quot;$0
echo &quot;第一个参数：&quot;$1
echo &quot;第二个参数：&quot;$2
echo &quot;第三个参数：&quot;$3
echo &quot;第四个参数：&quot;$4
</code></pre>
<p>然后执行该脚本：</p>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh 
acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4
文件名：./test.sh
第一个参数：1
第二个参数：2
第三个参数：3
第四个参数：4
</code></pre>
<p><strong>其它参数相关变量</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>代表文件传入的参数个数，如上例中值为4</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>由所有参数构成的用空格隔开的字符串，如上例中值为<code>&quot;$1 $2 $3 $4&quot;</code></td>
</tr>
<tr>
<td><code>$@</code></td>
<td>每个参数分别用双引号括起来的字符串，如上例中值为<code>&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;$4&quot;</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>脚本当前运行的进程ID</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误</td>
</tr>
<tr>
<td><code>$(command)</code></td>
<td>返回<code>command</code>这条命令的stdout（可嵌套）</td>
</tr>
<tr>
<td>`command<code>| 返回</code>command`这条命令的stdout（不可嵌套）</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="5数组"><strong>5.数组</strong></h1>
<p>数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。<br>
数组<strong>下标从0开始</strong>。</p>
<p><strong>定义</strong></p>
<p>数组用小括号表示，元素之间用空格隔开。例如：</p>
<pre><code class="language-shell">array=(1 abc &quot;def&quot; yxc)
</code></pre>
<p>也可以直接定义数组中某个元素的值：</p>
<pre><code class="language-shell">array[0]=1
array[1]=abc
array[2]=&quot;def&quot;
array[3]=yxc
</code></pre>
<p><strong>读取数组中某个元素的值</strong></p>
<p>格式：</p>
<pre><code class="language-shell">${array[index]}
</code></pre>
<p>例如：</p>
<pre><code class="language-shell">array=(1 abc &quot;def&quot; yxc)
echo ${array[0]}
echo ${array[1]}
echo ${array[2]}
echo ${array[3]}
</code></pre>
<p><strong>读取整个数组</strong><br>
格式：</p>
<pre><code class="language-shell">${array[@]}  # 第一种写法
${array[*]}  # 第二种写法
</code></pre>
<p>例如：</p>
<pre><code class="language-shell">array=(1 abc &quot;def&quot; yxc)

echo ${array[@]}  # 第一种写法
echo ${array[*]}  # 第二种写法
</code></pre>
<p><strong>数组长度</strong><br>
类似于字符串</p>
<pre><code class="language-shell">${#array[@]}  # 第一种写法
${#array[*]}  # 第二种写法
</code></pre>
<p>例如：</p>
<pre><code class="language-shell">array=(1 abc &quot;def&quot; yxc)

echo ${#array[@]}  # 第一种写法
echo ${#array[*]}  # 第二种写法
</code></pre>
<h1 id="6expr命令"><strong>6.expr命令</strong></h1>
<p><code>expr</code>命令用于求表达式的值，格式为：</p>
<pre><code class="language-shell">expr 表达式
</code></pre>
<p>表达式说明：</p>
<ul>
<li>用空格隔开每一项</li>
<li>用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）</li>
<li>对包含空格和其他特殊字符的字符串要用引号括起来</li>
<li>expr会在<code>stdout</code>中输出结果。如果为逻辑关系表达式，则结果为真，<code>stdout</code>为1，否则为0。</li>
<li>expr的<code>exit code</code>：如果为逻辑关系表达式，则结果为真，<code>exit code</code>为0，否则为1。</li>
</ul>
<p><strong>字符串表达式</strong></p>
<ul>
<li>
<p><code>length STRING</code><br>
返回<code>STRING</code>的长度</p>
</li>
<li>
<p><code>index STRING CHARSET</code></p>
<p><code>CHARSET</code>中任意单个字符在<code>STRING</code>中最前面的字符位置，下标从1开始。如果在<code>STRING</code>中完全不存在<code>CHARSET</code>中的字符，则返回0。</p>
</li>
<li>
<p><code>substr STRING POSITION LENGTH</code><br>
返回<code>STRING</code>字符串中从<code>POSITION</code>开始，长度最大为<code>LENGTH</code>的子串。如果<code>POSITION</code>或<code>LENGTH</code>为负数，0或非数值，则返回空字符串。</p>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-shell">str=&quot;Hello World!&quot;

echo `expr length &quot;$str&quot;`  # ``不是单引号，表示执行该命令，输出12
echo `expr index &quot;$str&quot; aWd`  # 输出7，下标从1开始
echo `expr substr &quot;$str&quot; 2 3`  # 输出 ell
</code></pre>
<p><strong>整数表达式</strong></p>
<p><code>expr</code>支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。</p>
<ul>
<li><code>+ -</code><br>
加减运算。两端参数会转换为整数，如果转换失败则报错。</li>
</ul>
<ul>
<li>
<p><code>* / %</code></p>
<p>乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错</p>
</li>
<li>
<p><code>()</code> 可以该表优先级，但需要用反斜杠转义</p>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-shell">a=3
b=4

echo `expr $a + $b`  # 输出7
echo `expr $a - $b`  # 输出-1
echo `expr $a \* $b`  # 输出12，*需要转义
echo `expr $a / $b`  # 输出0，整除
echo `expr $a % $b` # 输出3
echo `expr \( $a + 1 \) \* \( $b + 1 \)`  # 输出20，值为(a + 1) * (b + 1)
</code></pre>
<p><strong>逻辑关系表达式</strong></p>
<ul>
<li>
<p><code>|</code><br>
如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。</p>
</li>
<li>
<p><code>&amp;</code><br>
如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。</p>
</li>
<li>
<p><code>&lt; &lt;= = == != &gt;= &gt;</code><br>
比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。</p>
</li>
<li>
<p><code>()</code>可以该表优先级，但需要用反斜杠转义</p>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-shell">a=3
b=4

echo `expr $a \&gt; $b`  # 输出0，&gt;需要转义
echo `expr $a '&lt;' $b`  # 输出1，也可以将特殊字符用引号引起来
echo `expr $a '&gt;=' $b`  # 输出0
echo `expr $a \&lt;\= $b`  # 输出1

c=0
d=5

echo `expr $c \&amp; $d`  # 输出0
echo `expr $a \&amp; $b`  # 输出3
echo `expr $c \| $d`  # 输出5
echo `expr $a \| $b`  # 输出3
</code></pre>
<h1 id="7read命令"><strong>7.read命令</strong></h1>
<p><code>read</code>命令用于从标准输入中读取单行数据。当读到文件结束符时，<code>exit code</code>为1，否则为0。</p>
<p>参数说明</p>
<ul>
<li><code>-p</code>: 后面可以接提示信息</li>
<li><code>-t</code>：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令</li>
</ul>
<p>实例：</p>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ read name  # 读入name的值
acwing yxc  # 标准输入
acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值
acwing yxc  #标准输出
acs@9e0ebfcd82d7:~$ read -p &quot;Please input your name: &quot; -t 30 name  # 读入name的值，等待时间30秒
Please input your name: acwing yxc  # 标准输入
acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值
acwing yxc  # 标准输出
</code></pre>
<h1 id="8echo命令"><strong>8.echo命令</strong></h1>
<p><code>echo</code>用于输出字符串。命令格式：</p>
<pre><code class="language-shell">echo STRING
</code></pre>
<p><strong>显示普通字符串显示普通字符串</strong></p>
<pre><code class="language-shell">echo &quot;Hello AC Terminal&quot;
echo Hello AC Terminal  # 引号可以省略
</code></pre>
<p><strong>显示转义字符</strong></p>
<pre><code class="language-shell">echo &quot;\&quot;Hello AC Terminal\&quot;&quot;  # 注意只能使用双引号，如果使用单引号，则不转义
echo \&quot;Hello AC Terminal\&quot;  # 也可以省略双引号
</code></pre>
<p><strong>显示变量</strong></p>
<pre><code class="language-shell">name=yxc
echo &quot;My name is $name&quot;  # 输出 My name is yxc
</code></pre>
<h1 id="9printf命令"><strong>9.printf命令</strong></h1>
<p><code>printf</code>命令用于格式化输出，类似于<code>C/C++</code>中的<code>printf</code>函数。</p>
<p>默认<strong>不会在字符串末尾添加换行符。</strong></p>
<p>命令格式：</p>
<pre><code class="language-shell">printf format-string [arguments...]
</code></pre>
<p><strong>用法示例</strong><br>
脚本内容：</p>
<pre><code class="language-shell">printf &quot;%10d.\n&quot; 123  # 占10位，右对齐
printf &quot;%-10.2f.\n&quot; 123.123321  # 占10位，保留2位小数，左对齐
printf &quot;My name is %s\n&quot; &quot;yxc&quot;  # 格式化输出字符串
printf &quot;%d * %d = %d\n&quot;  2 3 `expr 2 \* 3` # 表达式的值作为参数
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">       123.
123.12    .
My name is yxc
2 * 3 = 6
</code></pre>
<h1 id="10-test命令与判断符号"><strong>10. test命令与判断符号[]</strong></h1>
<p><strong>逻辑运算符&amp;&amp;和||</strong></p>
<ul>
<li><code>&amp;&amp;</code> 表示与，<code>||</code> 表示或</li>
<li>二者具有短路原则：<br>
<code>expr1 &amp;&amp; expr2</code>：当<code>expr1</code>为假时，直接忽略<code>expr2</code><br>
<code>expr1 || expr2</code>：当<code>expr1</code>为真时，直接忽略<code>expr2</code></li>
<li>表达式的<code>exit code</code>为0，表示真；为非零，表示假。（与<code>C/C++</code>中的定义相反）</li>
</ul>
<p>test命令<br>
在命令行中输入<code>man test</code>，可以查看<code>test</code>命令的用法。</p>
<p><code>test</code>命令用于判断文件类型，以及对变量做比较。</p>
<p><code>test</code>命令用<code>exit code</code>返回结果，而不是使用<code>stdout</code>。0表示真，非0表示假。</p>
<p>例如：</p>
<pre><code class="language-shell">test 2 -lt 3  # 为真，返回值为0
echo $?  # 输出上个命令的返回值，输出0
</code></pre>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件
homework  output.txt  test.sh  tmp
acs@9e0ebfcd82d7:~$ test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;
exist  # test.sh 文件存在
acs@9e0ebfcd82d7:~$ test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;
Not exist  # testh2.sh 文件不存在
</code></pre>
<p><strong>文件类型判断</strong><br>
命令格式：</p>
<pre><code class="language-shell">test -e filename  # 判断文件是否存在
</code></pre>
<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>是否为文件</td>
</tr>
<tr>
<td>-d</td>
<td>是否为目录</td>
</tr>
</tbody>
</table>
<p><strong>文件权限判断</strong><br>
命令格式：</p>
<pre><code class="language-shell">test -r filename  # 判断文件是否可读
</code></pre>
<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>文件是否可读</td>
</tr>
<tr>
<td>-w</td>
<td>文件是否可写</td>
</tr>
<tr>
<td>-x</td>
<td>文件是否可执行</td>
</tr>
<tr>
<td>-s</td>
<td>是否为非空文件</td>
</tr>
</tbody>
</table>
<p><strong>整数间的比较</strong><br>
命令格式：</p>
<pre><code class="language-shell">test $a -eq $b  # a是否等于b
</code></pre>
<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>a是否等于b</td>
</tr>
<tr>
<td>-ne</td>
<td>a是否不等于b</td>
</tr>
<tr>
<td>-gt</td>
<td>a是否大于b</td>
</tr>
<tr>
<td>-lt</td>
<td>a是否小于b</td>
</tr>
<tr>
<td>-ge</td>
<td>a是否大于等于b</td>
</tr>
<tr>
<td>-le</td>
<td>a是否小于等于b</td>
</tr>
</tbody>
</table>
<p><strong>字符串比较</strong></p>
<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>test -z STRING</td>
<td>判断STRING是否为空，如果为空，则返回true</td>
</tr>
<tr>
<td>test -n STRING</td>
<td>判断STRING是否非空，如果非空，则返回true（-n可以省略）</td>
</tr>
<tr>
<td>test str1 == str2</td>
<td>判断str1是否等于str2</td>
</tr>
<tr>
<td>test str1 != str2</td>
<td>判断str1是否不等于str2</td>
</tr>
</tbody>
</table>
<p><strong>多重条件判定</strong><br>
命令格式：</p>
<pre><code class="language-shell">test -r filename -a -x filename
</code></pre>
<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>两条件是否同时成立</td>
</tr>
<tr>
<td>-o</td>
<td>两条件是否至少一个成立</td>
</tr>
<tr>
<td>!</td>
<td>取反。如 test ! -x file，当file不可执行时，返回true</td>
</tr>
</tbody>
</table>
<p><strong>判断符号[]</strong><br>
<code>[]</code>与<code>test</code>用法几乎一模一样，更常用于<code>if</code>语句中。另外<code>[[]]</code>是<code>[]</code>的加强版，支持的特性更多。</p>
<p>例如：</p>
<pre><code class="language-shell">[ 2 -lt 3 ]  # 为真，返回值为0
echo $?  # 输出上个命令的返回值，输出0
</code></pre>
<pre><code class="language-shel">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件
homework  output.txt  test.sh  tmp
acs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;
exist  # test.sh 文件存在
acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;
Not exist  # testh2.sh 文件不存在
</code></pre>
<p>注意：</p>
<ul>
<li><code>[]</code>内的每一项都要用空格隔开</li>
<li>中括号内的变量，最好用双引号括起来</li>
<li>中括号内的常数，最好用单或双引号括起来</li>
</ul>
<p>例如：</p>
<pre><code class="language-shell">name=&quot;acwing yxc&quot;
[ $name == &quot;acwing yxc&quot; ]  # 错误，等价于 [ acwing yxc == &quot;acwing yxc&quot; ]，参数太多
[ &quot;$name&quot; == &quot;acwing yxc&quot; ]  # 正确
</code></pre>
<h1 id="11判断语句"><strong>11.判断语句</strong></h1>
<p><strong>if…then形式</strong><br>
类似于<code>C/C++</code>中的<code>if-else</code>语句。</p>
<p><strong>单层if</strong><br>
命令格式：</p>
<pre><code class="language-shell">if condition
then
    语句1
    语句2
    ...
fi
</code></pre>
<p>示例：</p>
<pre><code class="language-shell">a=3
b=4

if [ &quot;$a&quot; -lt &quot;$b&quot; ] &amp;&amp; [ &quot;$a&quot; -gt 2 ]
then
    echo ${a}在范围内
fi
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">3在范围内
</code></pre>
<p><strong>单层if-else</strong><br>
命令格式</p>
<pre><code class="language-shell">if condition
then
    语句1
    语句2
    ...
else
    语句1
    语句2
    ...
fi
</code></pre>
<p>示例：</p>
<pre><code class="language-shell">a=3
b=4

if ! [ &quot;$a&quot; -lt &quot;$b&quot; ]
then
    echo ${a}不小于${b}
else
    echo ${a}小于${b}
fi
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">3小于4
</code></pre>
<p><strong>多层if-elif-elif-else</strong><br>
命令格式</p>
<pre><code class="language-shell">if condition
then
    语句1
    语句2
    ...
elif condition
then
    语句1
    语句2
    ...
elif condition
then
    语句1
    语句2
else
    语句1
    语句2
    ...
fi
</code></pre>
<p>示例：</p>
<pre><code class="language-shell">a=4

if [ $a -eq 1 ]
then
    echo ${a}等于1
elif [ $a -eq 2 ]
then
    echo ${a}等于2
elif [ $a -eq 3 ]
then
    echo ${a}等于3
else
    echo 其他
fi
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">其他
</code></pre>
<p><strong>case…esac形式</strong><br>
类似于<code>C/C++</code>中的<code>switch</code>语句。</p>
<p>命令格式</p>
<pre><code class="language-shell">case $变量名称 in
    值1)
        语句1
        语句2
        ...
        ;;  # 类似于C/C++中的break
    值2)
        语句1
        语句2
        ...
        ;;
    *)  # 类似于C/C++中的default
        语句1
        语句2
        ...
        ;;
esac
</code></pre>
<p>示例：</p>
<pre><code class="language-shell">a=4

case $a in
    1)
        echo ${a}等于1
        ;;  
    2)
        echo ${a}等于2
        ;;  
    3)                                                
        echo ${a}等于3
        ;;  
    *)
        echo 其他
        ;;  
esac
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">其他
</code></pre>
<h1 id="12循环语句"><strong>12.循环语句</strong></h1>
<p><strong>for…in…do…done</strong><br>
命令格式：</p>
<pre><code class="language-shell">for var in val1 val2 val3
do
    语句1
    语句2
    ...
done
</code></pre>
<p>示例1，输出a 2 cc，每个元素一行：</p>
<pre><code class="language-shell">for i in a 2 cc
do
    echo $i
done
</code></pre>
<p>示例2，输出当前路径下的所有文件名，每个文件名一行：</p>
<pre><code class="language-shell">for file in `ls`
do
    echo $file
done
</code></pre>
<p>示例3，输出1-10</p>
<pre><code class="language-shell">for i in $(seq 1 10)
do
    echo $i
done
</code></pre>
<p>示例4，使用<code>{1..10} 或者 {a..z}</code></p>
<pre><code class="language-shell">for i in {a..z}
do
    echo $i
done
</code></pre>
<p><strong>for ((…;…;…)) do…done</strong><br>
命令格式：</p>
<pre><code class="language-shell">for ((expression; condition; expression))
do
    语句1
    语句2
done
</code></pre>
<p>示例，输出1-10，每个数占一行：</p>
<pre><code class="language-shell">for ((i=1; i&lt;=10; i++))
do
    echo $i
done
</code></pre>
<p><strong>while…do…done循环</strong><br>
命令格式：</p>
<pre><code class="language-shell">while condition
do
    语句1
    语句2
    ...
done
</code></pre>
<p>示例，文件结束符为<code>Ctrl+d</code>，输入文件结束符后<code>read</code>指令返回false。</p>
<pre><code class="language-shell">while read name
do
    echo $name
done
</code></pre>
<p><strong>until…do…done循环</strong><br>
当条件为真时结束。</p>
<p>命令格式：</p>
<pre><code class="language-shell">until condition
do
    语句1
    语句2
    ...
done
</code></pre>
<p>示例，当用户输入<code>yes</code>或者<code>YES</code>时结束，否则一直等待读入。</p>
<pre><code class="language-shell">until [ &quot;${word}&quot; == &quot;yes&quot; ] || [ &quot;${word}&quot; == &quot;YES&quot; ]
do
    read -p &quot;Please input yes/YES to stop this program: &quot; word
done
</code></pre>
<p><strong>break命令</strong><br>
跳出当前一层循环，注意与<code>C/C++</code>不同的是：<code>break</code>不能跳出<code>case</code>语句。</p>
<p>示例</p>
<pre><code class="language-shell">while read name
do
    for ((i=1;i&lt;=10;i++))
    do
        case $i in
            8)
                break
                ;;
            *)
                echo $i
                ;;
        esac
    done
done
</code></pre>
<p>该示例每读入非EOF的字符串，会输出一遍1-7。<br>
该程序可以输入<code>Ctrl+d</code>文件结束符来结束，也可以直接用<code>Ctrl+c</code>杀掉该进程。</p>
<p><strong>continue命令</strong><br>
跳出当前循环。</p>
<p>示例：</p>
<pre><code class="language-shell">for ((i=1;i&lt;=10;i++))
do
    if [ `expr $i % 2` -eq 0 ]
    then
        continue
    fi
    echo $i
done
</code></pre>
<p>该程序输出1-10中的所有奇数。</p>
<p><strong>死循环的处理方式</strong><br>
如果AC Terminal可以打开该程序，则输入<code>Ctrl+c</code>即可。</p>
<p>否则可以直接关闭进程：</p>
<ol>
<li>使用<code>top</code>命令找到进程的PID</li>
<li>输入<code>kill -9 PID</code>即可关掉此进程</li>
</ol>
<h1 id="13函数"><strong>13.函数</strong></h1>
<p><code>bash</code>中的函数类似于<code>C/C++</code>中的函数，但<code>return</code>的返回值与<code>C/C++</code>不同，返回的是<code>exit code</code>，取值为0-255，0表示正常结束。</p>
<p>如果想获取函数的输出结果，可以通过<code>echo</code>输出到<code>stdout</code>中，然后通过<code>$(function_name)</code>来获取<code>stdout</code>中的结果。</p>
<p>函数的<code>return</code>值可以通过<code>$?</code>来获取。</p>
<p>命令格式：</p>
<pre><code class="language-shell">[function] func_name() {  # function关键字可以省略
    语句1
    语句2
    ...
}
</code></pre>
<p><strong>不获取 <code>return</code>值和<code>stdout</code>值</strong><br>
示例</p>
<pre><code class="language-shell">func() {
    name=yxc
    echo &quot;Hello $name&quot;
}

func
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">Hello yxc
</code></pre>
<p>获取 <code>return</code>值和<code>stdout</code>值<br>
不写<code>return</code>时，默认<code>return 0</code>。</p>
<p>示例</p>
<pre><code class="language-shell">func() {
    name=yxc
    echo &quot;Hello $name&quot;

    return 123
}

output=$(func)
ret=$?

echo &quot;output = $output&quot;
echo &quot;return = $ret&quot;
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">output = Hello yxc
return = 123
</code></pre>
<p><strong>函数的输入参数</strong><br>
在函数内，<code>$1</code>表示第一个输入参数，<code>$2</code>表示第二个输入参数，依此类推。</p>
<p>注意：函数内的<code>$0</code>仍然是文件名，而不是函数名。</p>
<p>示例：</p>
<pre><code class="language-shell">func() {  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0
    word=&quot;&quot;
    while [ &quot;${word}&quot; != 'y' ] &amp;&amp; [ &quot;${word}&quot; != 'n' ]
    do
        read -p &quot;要进入func($1)函数吗？请输入y/n：&quot; word
    done

    if [ &quot;$word&quot; == 'n' ]
    then
        echo 0
        return 0
    fi  

    if [ $1 -le 0 ] 
    then
        echo 0
        return 0
    fi  

    sum=$(func $(expr $1 - 1))
    echo $(expr $sum + $1)
}

echo $(func 10)
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">55
</code></pre>
<p><strong>函数内的局部变量</strong><br>
可以在函数内定义局部变量，作用范围仅在当前函数内。</p>
<p>可以在递归函数中定义局部变量。</p>
<p>命令格式：</p>
<pre><code class="language-shell">local 变量名=变量值
</code></pre>
<p>例如：</p>
<pre><code class="language-shell">#! /bin/bash

func() {
    local name=yxc
    echo $name
}
func

echo $name
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">yxc

</code></pre>
<p>第一行为函数内的name变量，第二行为函数外调用name变量，会发现此时该变量不存在。</p>
<h1 id="14exit命令"><strong>14.exit命令</strong></h1>
<p><code>exit</code>命令用来退出当前shell进程，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态。</p>
<p><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。</p>
<p><code>exit</code>退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。</p>
<p>示例：</p>
<p>创建脚本<code>test.sh</code>，内容如下：</p>
<pre><code class="language-shell">#! /bin/bash

if [ $# -ne 1 ]  # 如果传入参数个数等于1，则正常退出；否则非正常退出。
then
    echo &quot;arguments not valid&quot;
    exit 1
else
    echo &quot;arguments valid&quot;
    exit 0
fi
</code></pre>
<p>执行该脚本：</p>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh 
acs@9e0ebfcd82d7:~$ ./test.sh acwing
arguments valid
acs@9e0ebfcd82d7:~$ echo $?  # 传入一个参数，则正常退出，exit code为0
0
acs@9e0ebfcd82d7:~$ ./test.sh 
arguments not valid
acs@9e0ebfcd82d7:~$ echo $?  # 传入参数个数不是1，则非正常退出，exit code为1
1
</code></pre>
<h1 id="15文件重定向"><strong>15.文件重定向</strong></h1>
<p>每个进程默认打开3个文件描述符：</p>
<ul>
<li><code>stdin</code>标准输入，从命令行读取数据，文件描述符为0</li>
<li><code>stdout</code>标准输出，向命令行输出数据，文件描述符为1</li>
<li><code>stderr</code>标准错误输出，向命令行输出数据，文件描述符为2</li>
</ul>
<p>可以用文件重定向将这三个文件重定向到其他文件中。</p>
<p><strong>重定向命令列表</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>command &gt; file</code></td>
<td>将<code>stdout</code>重定向到<code>file</code>中</td>
</tr>
<tr>
<td><code>command &lt; file</code></td>
<td>将<code>stdin</code>重定向到<code>file</code>中</td>
</tr>
<tr>
<td><code>command &gt;&gt; file</code></td>
<td>将<code>stdout</code>以追加方式重定向到<code>file</code>中</td>
</tr>
<tr>
<td><code>command n&gt; file</code></td>
<td>将文件描述符<code>n</code>重定向到<code>file</code>中</td>
</tr>
<tr>
<td><code>command n&gt;&gt; file</code></td>
<td>将文件描述符<code>n</code>以追加方式重定向到<code>file</code>中</td>
</tr>
</tbody>
</table>
<p><strong>输入和输出重定向</strong></p>
<pre><code class="language-shell">echo -e &quot;Hello \c&quot; &gt; output.txt  # 将stdout重定向到output.txt中
echo &quot;World&quot; &gt;&gt; output.txt  # 将字符串追加到output.txt中

read str &lt; output.txt  # 从output.txt中读取字符串

echo $str  # 输出结果：Hello World
</code></pre>
<p><strong>同时重定向stdin和stdout</strong><br>
创建bash脚本：</p>
<pre><code class="language-shell">#! /bin/bash

read a
read b

echo $(expr &quot;$a&quot; + &quot;$b&quot;)
</code></pre>
<p>创建input.txt，里面的内容为：</p>
<pre><code class="language-shell">3
4
</code></pre>
<p>执行命令：</p>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限
acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中
acs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容
7
</code></pre>
<h1 id="16引入外部脚本"><strong>16.引入外部脚本</strong></h1>
<p>类似于<code>C/C++</code>中的<code>include</code>操作，<code>bash</code>也可以引入其他文件中的代码。</p>
<p>语法格式：</p>
<pre><code class="language-shell">. filename  # 注意点和文件名之间有一个空格

或

source filename
</code></pre>
<p><strong>示例</strong><br>
创建<code>test1.sh</code>，内容为：</p>
<pre><code class="language-shell">#! /bin/bash

name=yxc  # 定义变量name
</code></pre>
<p>然后创建<code>test2.sh</code>，内容为：</p>
<pre><code class="language-shell">#! /bin/bash

source test1.sh # 或 . test1.sh

echo My name is: $name  # 可以使用test1.sh中的变量
</code></pre>
<p>执行命令：</p>
<pre><code class="language-shell">acs@9e0ebfcd82d7:~$ chmod +x test2.sh 
acs@9e0ebfcd82d7:~$ ./test2.sh 
My name is: yxc
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[随便写写题]]></title>
        <id>https://zzulihrs.github.io/post/sui-bian-xie-xie-ti/</id>
        <link href="https://zzulihrs.github.io/post/sui-bian-xie-xie-ti/">
        </link>
        <updated>2022-01-02T07:11:11.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>2022/01/02<br>
<a href="#1.1">leetcode第274周赛D 5970.参加会议的最多员工数</a><br>
<a href="#1.2">cf Good Bye 2021 D. Keep the Average High</a></li>
<li>2022/01/03<br>
<a href="#2.1">cf edu120 D. Shuffle</a><br>
<a href="#2.2">cf Hello 2022 A. Stable Arrangement of Rooks</a><br>
<a href="#2.3">cf Hello 2022 B. Integers Shop</a></li>
<li>2022/01/06<br>
<a href="#3.1">第八届蓝桥杯 A组 正则问题</a></li>
<li>2022/01<br>
<a href="#4.1">leetcod第68场双周赛 2116. 判断一个括号字符串是否有效</a></li>
</ul>
<h2 id = "1.1"><h2>
# 2022/01/02
<h2 id="5970-参加会议的最多员工数"><a href="https://leetcode-cn.com/contest/weekly-contest-274/problems/maximum-employees-to-be-invited-to-a-meeting/">5970. 参加会议的最多员工数</a></h2>
<p>leetcode第274周赛D题</p>
<p>挺有意思的题</p>
<p>思路：</p>
<p>两种情况</p>
<p>1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况</p>
<p>2）最大环，只能放一个</p>
<p>取两种情况的最大值</p>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

class Solution {
public:
	#define maxsize 100010
	#define pb push_back
	#define fi first
	#define se second
	#define SZ(x) (int)x.size()
	#define ALL(x) x.begin(), x.end()
	/*
	两种情况
	1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况
	2）最大环，只能放一个
	取两种情况的最大值
	*/

	vector&lt;int&gt; e[maxsize], re[maxsize];
	int d[maxsize];

    int maximumInvitations(vector&lt;int&gt;&amp; a) {
    	int n = SZ(a);

  		for(int i = 0; i &lt; SZ(a); ++i)
  		{
  			e[i].pb(a[i]);
  			re[a[i]].pb(i);
  			d[a[i]]++;
  		}
  		queue&lt;int&gt; q; 
  		vector&lt;int&gt; dp(n, 1);
  		for(int i = 0; i &lt; n; ++i) 
  			if(!d[i]) q.push(i);
  		while(SZ(q)) {
  			int u = q.front(); q.pop();
  			dp[a[u]] = max(dp[a[u]], dp[u]+1);
  			if(--d[a[u]] == 0) q.push(a[u]);
  		}
  		int ans = 0;
  		for(int i = 0; i &lt; n; ++i)
  			if(a[a[i]] == i) //两个之间互相喜欢，形成一个集合
  				ans += dp[i]+dp[a[i]];
 		ans /= 2; //计算了A, B和B, A两种情况，去重

  		//求最大环
  		vector&lt;int&gt; vis(n, 0);
  		for(int i = 0; i &lt; n; ++i) {
  			if(vis[i]) continue;
  			vector&lt;int&gt; b;
  			int x = i;
  			while(!vis[x]) { 
  				vis[x] = 1;
  				b.pb(x);
  				x = a[x];
  			}
  			for(int j = 0; j &lt; SZ(b); ++j)
  				if(b[j] == x)  //x是环上的点，也是与链的交点
  				ans = max(ans, SZ(b)-j);
  		}


  		return ans;	      
    }
}T;

void sol()
{
	vector&lt;int&gt; a{3,0,1,4,1};
	db1(T.maximumInvitations(a));
}
signed main()
{	
	//IOS
    //int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}
</code></pre>
<h2 id = "1.2"><h2>
<h2 id="d-keep-the-average-high"><a href="https://codeforces.com/contest/1616/problem/D">D. Keep the Average High</a></h2>
<p>思路：无脑dp，同时记录选择或不选的<strong><strong>最大长度</strong></strong>和<strong><strong>最小sum(最坏情况)</strong></strong></p>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

int n, m;
int a[N];
int dp[N][2]; //选与不选的最大长度
int sum[N][2];//对应的最小sum
//te

void sol()
{
	int x;
	cin&gt;&gt;n;
	for(int i = 1; i &lt;= n; ++i) cin&gt;&gt;a[i];
	cin&gt;&gt;x;
	for(int i = 1; i &lt;= n; ++i) a[i] -= x;
	dp[1][0] = 0;
	dp[1][1] = 1;
	sum[1][0] = 0;
	sum[1][1] = a[1];

	for(int i = 2;i &lt;= n; ++i) {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
		sum[i][0] = 0;

		dp[i][1] = dp[i-1][0]+1;
		sum[i][1] = a[i];
		if(dp[i][1] &lt; dp[i-1][1]+1&amp;&amp;sum[i-1][1]+a[i]&gt;=0) {
			dp[i][1] = dp[i-1][1]+1;
			sum[i][1] = min(sum[i-1][1]+a[i], a[i]);
		}

	}
	//gg;
	//for(int i = 1; i &lt;= n; ++i) db2(dp[i][0], dp[i][1]);
	cout&lt;&lt;max(dp[n][0], dp[n][1])&lt;&lt;endl;
}
signed main()
{	
	IOS
    int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}

</code></pre>
<h1 id="20220103">2022/01/03</h1>
<h2 id="2.1"><h2>
<h2 id="d-shuffle"><a href="https://codeforces.com/problemset/problem/1622/D">D. Shuffle</a></h2>
<p>题意：对01串进行操作：取其中1的个数为k的连续子串，将这个子串重新排列。问至少一次操作后的01串有多少种情况</p>
<p>思路：</p>
<pre><code class="language-txt">pos记录每个1的位置
1和0的排列可以转换成小球放盒问题，m个1，n个0，等价于m+1个不同盒子，n个相同球的排列数
如何计算所有排列
以7 2  1100110为例

+1100的排列数
+1001的排列数 - 100的排列数，这是1100与1001之间的重复
以此类推
+00110的排列数 - 001的排列数
</code></pre>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 5100;
const int mod = 998244353;

ll fac[N], inv[N];

ll ksm(ll x, ll y)
{
	ll ans = 1;
	while(y)
	{
		if(y&amp;1) ans = ans*x%mod;
		x = x*x%mod;
		y &gt;&gt;= 1;
	}
	return ans;
}
void init()
{
	fac[0] = inv[0] = 1;
	for(int i = 1; i &lt;= 10000; ++i) fac[i] = fac[i-1]*i%mod;
	inv[10000] = ksm(fac[10000], mod-2);
	for(int i = 10000; i &gt;= 1; --i) inv[i-1] = inv[i]*i%mod;
}
ll C(int n, int m)
{
	return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
ll calc(int m, int n)//m个不同盒子，n个相同小球的排列数
{
	return C(m+n-1, m-1);
}
int a[M];

vector&lt;int&gt; pos;
bool vis[M];

void sol()
{
	int n, k;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%1d&quot;, &amp;a[i]);
	for(int i = 1; i &lt;= n; ++i)
		if(a[i]) pos.pb(i);
	
	if(SZ(pos) &lt; k||k==0) {
		puts(&quot;1&quot;);
		return ;
	}

	ll ans = 0;
	int l = 1, r = n;
	pos.pb(n+1);
	for(int i = k-1; i+1 &lt; SZ(pos); i++) {
		r = pos[i+1]-1;
		//db2(l, r);
		ans = (ans+calc(k+1, r-l-k+1))%mod;
 		if(i!=k-1) //第一个区间不用去重
		ans = (ans-calc(k, pos[i]-1-l-(k-1)+1)+mod)%mod; //去重，与前一个区间重复
		//重复的是(l, pos[i]-1)区间，里面有k-1个1
		l = pos[i-k+1]+1;
	}
	printf(&quot;%I64d\n&quot;, ans);
}
signed main()
{	
	init();
        sol();
}
</code></pre>
<h2 id = "2.2"><h2>
<h2 id="a-stable-arrangement-of-rooks"><a href="https://codeforces.com/contest/1621/problem/A">A. Stable Arrangement of Rooks</a></h2>
<p>题意：在n*n的棋盘上放置m个车，要求车移动到相邻的四个位置也不会与其他的车冲突，车类似于象棋中的车<br>
思路：对角线上放置，且在对角线要隔着一个，防止冲突</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 5100;
const int mod = 998244353;
int n, m;
char s[M][M];

void sol()
{
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 0; i &lt; n; ++i) {
		for(int j = 0; j &lt; n; ++j) s[i][j] = '.';
		s[i][n] = '\0';
	}
	if(n+1 &lt; 2*m) {
		puts(&quot;-1&quot;);
		return ;
	}
	for(int i = 0; i &lt; m; ++i)
		s[i*2][i*2] = 'R';
	for(int i = 0; i &lt; n; ++i)
		puts(s[i]);
}
signed main()
{	
    int _ = 1; scanf(&quot;%d&quot;, &amp;_);	while (_--)
        sol();
}
</code></pre>
<h2 id = "2.3"><h2>
<p><a href="https://codeforces.com/contest/1621/problem/B">B. Integers Shop</a><br>
思路：取<code>两端区间的最小值的和</code>  <code>包含所有数字区间的最小的值</code>两者的最小值</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x7f7f7f7f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 5100;
const int mod = 998244353;

int n, m;
int l[N], r[N], c[N];
/*
左端最小的区间，右端最大的区间
*/

void sol()
{
	scanf(&quot;%d&quot;, &amp;n);
	int L = 1, R = 1;

	int temp = 1, ans = INF;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;l[i], &amp;r[i], &amp;c[i]);
		if(l[L] &gt; l[i]) L = i;
		else if(l[L]==l[i]&amp;&amp;c[L]&gt;c[i]) L = i;
		else if(l[L]==l[i]&amp;&amp;c[L]==c[i]&amp;&amp;r[L]&lt;r[i]) L = i;

		if(r[R] &lt; r[i]) R = i;
		else if(r[R]==r[i]&amp;&amp;c[R]&gt;c[i]) R = i;
		else if(r[R]==r[i]&amp;&amp;c[R]==c[i]&amp;&amp;l[L]&gt;l[i]) R = i;

		if(l[i]==l[L]&amp;&amp;r[i]==r[R]) {
			if(l[i]==l[temp]&amp;&amp;r[i]==r[temp]&amp;&amp;c[i]&lt;=c[temp])
				temp = i, ans = c[i]; 
			if(l[i]!=l[temp]||r[i]!=r[temp])
				temp = i, ans = c[i];
		}
		if(l[temp]!=l[L]||r[temp]!=r[R]) ans = INF;

		printf(&quot;%d\n&quot;, min(ans, c[L]+c[R]));
	}
}
signed main()
{	
    int _ = 1; scanf(&quot;%d&quot;, &amp;_);	while (_--)
        sol();
}
</code></pre>
<h2 id = "3.1">正则表达式<h2>
<p>额，数据有问题，()数量都不想等</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x7f7f7f7f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 11000;
const int mod = 998244353;

int n, m;
/*
a|b 匹配a或b
那么找最大的就行
记录每个(的)位置，|的下一个|位置
递归处理
*/
char s[M];
int pos[M];
int nex[M];
int dp[M];

int dfs(int l, int r)
{
	if(l &gt; r) return 0;
	db2(l, r);
	if(~dp[l-1]) return dp[l-1];
	int ans = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(s[i] == 'x') ans++;
		else if(s[i] == '(') {
			ans += dfs(i+1, pos[i]-1);
			i = pos[i];
			db1(pos[i]);
		}
		else {
			int t = dfs(i+1, r);
			ans = max(ans, t);
			i = r;
		}
	}
	return dp[l-1]=ans;
}

void sol()
{
	MEM(dp, -1);
	scanf(&quot;%s&quot;, s+1);
	n = strlen(s+1);
    if(n&gt;100) return ;
	stack&lt;int&gt; fh;

	int a = 0, b = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(s[i] == '(') a++;
		else if(s[i] == ')') b++;
		if(s[i] == '(') fh.push(i);
		else if(s[i] == ')') pos[fh.top()] = i, fh.pop();
	}
	db2(a, b);
	return ;

	int temp = n+1;
	for(int i = n; i &gt;= 1; --i) {
		if(s[i] == '|') nex[i] = temp, temp = i;
	}

	int ans = dfs(1, n);

	printf(&quot;%d\n&quot;, ans);
}
signed main()
{	
    //int _ = 1; scanf(&quot;%d&quot;, &amp;_);	while (_--)
        sol();
}
</code></pre>
<h2 id = "4.1"><h2>
<p><a href="https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/">2116. 判断一个括号字符串是否有效</a></p>
<pre><code class="language-c++">class Solution {
public:
	int n;
    bool canBeValid(string s, string lock) {
  		 n = SZ(s);
  		 int l = 0, r = 0;
  		 if(n%2) return false;

  		 for(int i = 0; i &lt; n; ++i) {
  		 	int a;
  		 	if(s[i] == '(') a = 1;
  		 	else a = -1;

  		 	if(lock[i] == '1') {
  		 		if(a) r = max(0, r), l = max(0, l);
  		 		l += a;
  		 		r += a;
  		 		if(r &lt; 0) return false;
  		 	}
  		 	else {
  		 		l--;
  		 		r++;
  		 	}

  		 }
  		 return l&lt;=0&amp;&amp;r&gt;=0;
    }
}T;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux基础]]></title>
        <id>https://zzulihrs.github.io/post/linux-ji-chu-ke/</id>
        <link href="https://zzulihrs.github.io/post/linux-ji-chu-ke/">
        </link>
        <updated>2022-01-02T01:50:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-常用文件管理命令">1. 常用文件管理命令</h1>
<ol>
<li>
<h3 id="常用命令介绍">常用命令介绍</h3>
</li>
</ol>
<pre><code class="language-txt">(1) ctrl c: 取消命令，并且换行
(2) ctrl u: 清空本行命令
(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项
(4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件
(5) pwd: 显示当前路径
(6) cd XXX: 进入XXX目录下, cd .. 返回上层目录
(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt
(8) mkdir XXX: 创建目录XXX
(9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹
(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令
(11) touch XXX: 创建一个文件
(12) cat XXX: 展示文件XXX中的内容
(13) 复制文本
windows/Linux下：Ctrl + insert，Mac下：command + c
(14) 粘贴文本
windows/Linux下：Shift + insert，Mac下：command + v
</code></pre>
<ol start="2">
<li>创建作业 &amp; 测试作业的正确性</li>
</ol>
<pre><code class="language-txt">homework 1 create 可以重新创建所有lesson_1的作业
homework 1 create id 可以单独创建lesson_1的第id个作业. e.g.
homework 1 create 0 可以只重新创建lesson_1的第0个作业
homework 1 test 可以评测lesson_1的所有作业
</code></pre>
<ol start="3">
<li>作业</li>
</ol>
<pre><code class="language-txt">创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：
(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c
(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak
(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt
(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下
(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除
(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除
(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作
(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，
将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt;
将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt;
将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;
(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作
(9) 进入homework_9文件夹，将其中所有txt类型的文件删除
</code></pre>
<h1 id="2-tmux和vim">2. tmux和vim</h1>
<ol>
<li>tmux教程</li>
</ol>
<pre><code class="language-txt">功能：
    (1) 分屏。
    (2) 允许断开Terminal连接后，继续运行进程。
结构：
    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。
    实例：
        tmux:
            session 0:
                window 0:
                    pane 0
                    pane 1
                    pane 2
                    ...
                window 1
                window 2
                ...
            session 1
            session 2
            ...
操作：
    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。
    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。
    (3) 按下Ctrl + a后手指松开，然后按&quot;（注意是双引号&quot;）：将当前pane上下平分成两个pane。
    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。
    (5) 鼠标点击可以选pane。
    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。
    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。
    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。
    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。
    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。
    (11) tmux a：打开之前挂起的session。
    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。
        方向键 —— 上：选择上一项 session/window/pane
        方向键 —— 下：选择下一项 session/window/pane
        方向键 —— 右：展开当前项 session/window
        方向键 —— 左：闭合当前项 session/window
    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。
    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。
    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。
    (16) 鼠标滚轮：翻阅当前pane内的内容。
    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）
    (18) tmux中复制/粘贴文本的通用方式：
        (1) 按下Ctrl + a后松开手指，然后按[
        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板
        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处
</code></pre>
<ol start="2">
<li>vim教程</li>
</ol>
<pre><code class="language-txt">功能：
    (1) 命令行模式下的文本编辑器。
    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。
    (3) 使用方式：vim filename
        如果已有该文件，则打开它。
        如果没有该文件，则打开个一个新的文件，并命名为filename
模式：
    (1) 一般命令模式
        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。
    (2) 编辑模式
        在一般命令模式里按下i，会进入编辑模式。
        按下ESC会退出编辑模式，返回到一般命令模式。
    (3) 命令行模式
        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。
        可以查找、替换、保存、退出、配置编辑器等。
操作：
    (1) i：进入编辑模式
    (2) ESC：进入一般命令模式
    (3) h 或 左箭头键：光标向左移动一个字符
    (4) j 或 向下箭头：光标向下移动一个字符
    (5) k 或 向上箭头：光标向上移动一个字符
    (6) l 或 向右箭头：光标向右移动一个字符
    (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符
    (8) 0 或 功能键[Home]：光标移动到本行开头
    (9) $ 或 功能键[End]：光标移动到本行末尾
    (10) G：光标移动到最后一行
    (11) :n 或 nG：n为数字，光标移动到第n行
    (12) gg：光标移动到第一行，相当于1G
    (13) n&lt;Enter&gt;：n为数字，光标向下移动n行
    (14) /word：向光标之下寻找第一个值为word的字符串。
    (15) ?word：向光标之上寻找第一个值为word的字符串。
    (16) n：重复前一个查找操作
    (17) N：反向重复前一个查找操作
    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2
    (19) :1,$s/word1/word2/g：将全文的word1替换为word2
    (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。
    (21) v：选中文本
    (22) d：删除选中的文本
    (23) dd: 删除当前行
    (24) y：复制选中的文本
    (25) yy: 复制当前行
    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴
    (27) u：撤销
    (28) Ctrl + r：取消撤销
    (29) 大于号 &gt;：将选中的文本整体向右缩进一次
    (30) 小于号 &lt;：将选中的文本整体向左缩进一次
    (31) :w 保存
    (32) :w! 强制保存
    (33) :q 退出
    (34) :q! 强制退出
    (35) :wq 保存并退出
    (36) :set paste 设置成粘贴模式，取消代码自动缩进
    (37) :set nopaste 取消粘贴模式，开启代码自动缩进
    (38) :set nu 显示行号
    (39) :set nonu 隐藏行号
    (40) gg=G：将全文代码格式化
    (41) :noh 关闭查找关键词高亮
    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令
    (43) Ctrl+z：后台挂起当前进程，通过fg+id可以恢复
异常处理：
    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。
    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：
        (1) 找到正在打开该文件的程序，并退出
        (2) 直接删掉该swp文件即可
</code></pre>
<ol start="3">
<li>创建作业 &amp; 测试作业的正确性</li>
</ol>
<pre><code class="language-txt">homework 2 create 可以重新创建所有lesson_2的作业。
homework 2 create id 可以单独创建lesson_2的第id个作业. e.g.
    homework 2 create 0 可以只重新创建lesson_2的第0个作业
homework 2 test 可以评测lesson_2的所有作业
</code></pre>
<ol start="4">
<li>作业</li>
</ol>
<pre><code class="language-txt">创建好作业后，先进入文件夹/home/acs/homework/lesson_2/，然后：
(0) 进入homework_0文件夹，创建文件names.txt，并顺次将下列姓名写入该文件，每个名字占一行。
    AcWing、yxc、Bob、张强、李明、Alice
(1) 进入homework_1文件夹，打开problem.txt，并依次删除下列字符：
    [1] 最后一行第101个字符
    [2] 第3行第8个字符
    [3] 第1行第30个字符
    [4] 第16行第55个字符
    [5] 第9行第80个字符
    最后保存文件并退出。
(2) 进入homework_2文件夹，打开problem.txt，并依次执行如下操作：
    [1] 在第1个&quot;two&quot;的后面添加&quot;abc&quot;
    [2] 在第2个&quot;two&quot;的前面添加&quot;def&quot;
    [3] 将第3个&quot;two&quot;后面的连续12个字符删掉
    [4] 将第4个&quot;two&quot;所在的行删掉
    最后保存文件并退出。
(3) 进入homework_3文件夹，打开problem.txt，并依次执行如下操作：
    [1] 将第5行至第15行中所有of替换成OF。
    [2] 将全文中所有的the替换成THE。
    [3] 将第偶数个is替换成IS，第奇数个is不变。下标从1开始。
(4) 进入homework_4文件夹，打开problem.txt，并依次执行如下操作：
    [1] 删除第11行
    [2] 将所删除的行粘贴到文件最后一行的下一行
    [3] 复制第5行
    [4] 将所复制的行粘贴到文件当前最后一行的下一行
(5) 进入homework_5文件夹，打开problem.txt，并依次执行如下操作：
    [1] 删除第11行第15个字符（包含该字符）至第13行第5个字符（包含该字符）
    [2] 将所删除的内容粘贴到文件末尾（注意不要另起一行）
    [3] 复制第5行第88个字符（包含该字符）至第7行第6个字符（包含该字符）
    [4] 将所复制的内容粘贴到当前文件末尾（注意不要另起一行）
(6) 进入homework_6文件夹，并依次执行如下操作：
    [1] 清空source0.cpp
    [2] 将source1.cpp中的第1-3行和第12-24行复制到source0.cpp中
(7) 进入homework_7文件夹，格式化source.cpp
(8) 进入homework_8文件夹，打开source.cpp，并依次执行如下操作：
    [1] 将第15-21行向右缩进2次。
    [2] 将第22-23行向左缩进1次。
(9) 进入homework_9文件夹，打开链接：https://www.acwing.com/activity/content/code/content/1694465/
    新建文件source.cpp，将链接中的代码抄进source.cpp文件中。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://zzulihrs.github.io/post/shu-ju-ku-ji-chu/</id>
        <link href="https://zzulihrs.github.io/post/shu-ju-ku-ji-chu/">
        </link>
        <updated>2022-01-01T07:03:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1NJ411J79W">狂神说</a></p>
<h3 id="什么是数据库">什么是数据库</h3>
<p>数据库(DB, DataBase)</p>
<p>概念：数据仓库，软件，安装在os上！SQL可以存储大量数据, 500万</p>
<p>作用：存储数据，管理数据</p>
<h3 id="数据库分类">数据库分类</h3>
<p>关系型数据库：（SQL）</p>
<ul>
<li>MYSQL, Oracle, sql Server, DB2, SQllit</li>
<li>通过表和表之间，行和行之间的关系进行数据的存储，学员信息表，考勤表</li>
</ul>
<p>非关系型数据库：(NoSQL) Not only</p>
<ul>
<li>Redits, MongDB</li>
<li>非关系型数据库，对象存储，通过对象的自身的属性来决定</li>
</ul>
<h4 id="dbms数据库管理系统">DBMS(数据库管理系统)：</h4>
<ul>
<li>数据库的管理软件，科学有效管理我们的数据，维护和获取数据</li>
<li>MYSQL</li>
</ul>
<h3 id="mysql介绍">MYSQL介绍</h3>
<p>最好的关系型数据库</p>
<p>开源软件</p>
<p>适用于中小</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[algorithm]]></title>
        <id>https://zzulihrs.github.io/post/test/</id>
        <link href="https://zzulihrs.github.io/post/test/">
        </link>
        <updated>2021-12-28T12:32:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
]]></content>
    </entry>
</feed>