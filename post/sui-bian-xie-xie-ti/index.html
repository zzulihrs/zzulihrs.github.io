<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>随便写写题 | blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zzulihrs.github.io/favicon.ico?v=1641287478734">
<link rel="stylesheet" href="https://zzulihrs.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="
2022/01/02
leetcode第274周赛D 5970.参加会议的最多员工数
cf Good Bye 2021 D. Keep the Average High
2022/01/03
cf edu120 D. Shuffle
cf..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zzulihrs.github.io">
        <img src="https://zzulihrs.github.io/images/avatar.png?v=1641287478734" class="site-logo">
        <h1 class="site-title">blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      fw
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://zzulihrs.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">随便写写题</h2>
            <div class="post-date">2022-01-02</div>
            
            <div class="post-content" v-pre>
              <ul>
<li>2022/01/02<br>
<a href="#1.1">leetcode第274周赛D 5970.参加会议的最多员工数</a><br>
<a href="#1.2">cf Good Bye 2021 D. Keep the Average High</a></li>
<li>2022/01/03<br>
<a href="#2.1">cf edu120 D. Shuffle</a><br>
<a href="#2.2">cf Hello 2022 A. Stable Arrangement of Rooks</a><br>
<a href="#2.3">cf Hello 2022 B. Integers Shop</a></li>
</ul>
<h2 id = "1.1"><h2>
# 2022/01/02
<h2 id="5970-参加会议的最多员工数"><a href="https://leetcode-cn.com/contest/weekly-contest-274/problems/maximum-employees-to-be-invited-to-a-meeting/">5970. 参加会议的最多员工数</a></h2>
<p>leetcode第274周赛D题</p>
<p>挺有意思的题</p>
<p>思路：</p>
<p>两种情况</p>
<p>1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况</p>
<p>2）最大环，只能放一个</p>
<p>取两种情况的最大值</p>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

class Solution {
public:
	#define maxsize 100010
	#define pb push_back
	#define fi first
	#define se second
	#define SZ(x) (int)x.size()
	#define ALL(x) x.begin(), x.end()
	/*
	两种情况
	1）A, B互相喜欢，两个人的追随者都可以放上，找出所有符合条件的情况
	2）最大环，只能放一个
	取两种情况的最大值
	*/

	vector&lt;int&gt; e[maxsize], re[maxsize];
	int d[maxsize];

    int maximumInvitations(vector&lt;int&gt;&amp; a) {
    	int n = SZ(a);

  		for(int i = 0; i &lt; SZ(a); ++i)
  		{
  			e[i].pb(a[i]);
  			re[a[i]].pb(i);
  			d[a[i]]++;
  		}
  		queue&lt;int&gt; q; 
  		vector&lt;int&gt; dp(n, 1);
  		for(int i = 0; i &lt; n; ++i) 
  			if(!d[i]) q.push(i);
  		while(SZ(q)) {
  			int u = q.front(); q.pop();
  			dp[a[u]] = max(dp[a[u]], dp[u]+1);
  			if(--d[a[u]] == 0) q.push(a[u]);
  		}
  		int ans = 0;
  		for(int i = 0; i &lt; n; ++i)
  			if(a[a[i]] == i) //两个之间互相喜欢，形成一个集合
  				ans += dp[i]+dp[a[i]];
 		ans /= 2; //计算了A, B和B, A两种情况，去重

  		//求最大环
  		vector&lt;int&gt; vis(n, 0);
  		for(int i = 0; i &lt; n; ++i) {
  			if(vis[i]) continue;
  			vector&lt;int&gt; b;
  			int x = i;
  			while(!vis[x]) { 
  				vis[x] = 1;
  				b.pb(x);
  				x = a[x];
  			}
  			for(int j = 0; j &lt; SZ(b); ++j)
  				if(b[j] == x)  //x是环上的点，也是与链的交点
  				ans = max(ans, SZ(b)-j);
  		}


  		return ans;	      
    }
}T;

void sol()
{
	vector&lt;int&gt; a{3,0,1,4,1};
	db1(T.maximumInvitations(a));
}
signed main()
{	
	//IOS
    //int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}
</code></pre>
<h2 id = "1.2"><h2>
<h2 id="d-keep-the-average-high"><a href="https://codeforces.com/contest/1616/problem/D">D. Keep the Average High</a></h2>
<p>思路：无脑dp，同时记录选择或不选的<strong><strong>最大长度</strong></strong>和<strong><strong>最小sum(最坏情况)</strong></strong></p>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 65;
const int mod = 1713222373;

int n, m;
int a[N];
int dp[N][2]; //选与不选的最大长度
int sum[N][2];//对应的最小sum
//te

void sol()
{
	int x;
	cin&gt;&gt;n;
	for(int i = 1; i &lt;= n; ++i) cin&gt;&gt;a[i];
	cin&gt;&gt;x;
	for(int i = 1; i &lt;= n; ++i) a[i] -= x;
	dp[1][0] = 0;
	dp[1][1] = 1;
	sum[1][0] = 0;
	sum[1][1] = a[1];

	for(int i = 2;i &lt;= n; ++i) {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
		sum[i][0] = 0;

		dp[i][1] = dp[i-1][0]+1;
		sum[i][1] = a[i];
		if(dp[i][1] &lt; dp[i-1][1]+1&amp;&amp;sum[i-1][1]+a[i]&gt;=0) {
			dp[i][1] = dp[i-1][1]+1;
			sum[i][1] = min(sum[i-1][1]+a[i], a[i]);
		}

	}
	//gg;
	//for(int i = 1; i &lt;= n; ++i) db2(dp[i][0], dp[i][1]);
	cout&lt;&lt;max(dp[n][0], dp[n][1])&lt;&lt;endl;
}
signed main()
{	
	IOS
    int _ = 1;	cin&gt;&gt;_;	while (_--)
        sol();
}

</code></pre>
<h1 id="20220103">2022/01/03</h1>
<h2 id="2.1"><h2>
<h2 id="d-shuffle"><a href="https://codeforces.com/problemset/problem/1622/D">D. Shuffle</a></h2>
<p>题意：对01串进行操作：取其中1的个数为k的连续子串，将这个子串重新排列。问至少一次操作后的01串有多少种情况</p>
<p>思路：</p>
<pre><code class="language-txt">pos记录每个1的位置
1和0的排列可以转换成小球放盒问题，m个1，n个0，等价于m+1个不同盒子，n个相同球的排列数
如何计算所有排列
以7 2  1100110为例

+1100的排列数
+1001的排列数 - 100的排列数，这是1100与1001之间的重复
以此类推
+00110的排列数 - 001的排列数
</code></pre>
<p>代码：</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 5100;
const int mod = 998244353;

ll fac[N], inv[N];

ll ksm(ll x, ll y)
{
	ll ans = 1;
	while(y)
	{
		if(y&amp;1) ans = ans*x%mod;
		x = x*x%mod;
		y &gt;&gt;= 1;
	}
	return ans;
}
void init()
{
	fac[0] = inv[0] = 1;
	for(int i = 1; i &lt;= 10000; ++i) fac[i] = fac[i-1]*i%mod;
	inv[10000] = ksm(fac[10000], mod-2);
	for(int i = 10000; i &gt;= 1; --i) inv[i-1] = inv[i]*i%mod;
}
ll C(int n, int m)
{
	return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
ll calc(int m, int n)//m个不同盒子，n个相同小球的排列数
{
	return C(m+n-1, m-1);
}
int a[M];

vector&lt;int&gt; pos;
bool vis[M];

void sol()
{
	int n, k;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%1d&quot;, &amp;a[i]);
	for(int i = 1; i &lt;= n; ++i)
		if(a[i]) pos.pb(i);
	
	if(SZ(pos) &lt; k||k==0) {
		puts(&quot;1&quot;);
		return ;
	}

	ll ans = 0;
	int l = 1, r = n;
	pos.pb(n+1);
	for(int i = k-1; i+1 &lt; SZ(pos); i++) {
		r = pos[i+1]-1;
		//db2(l, r);
		ans = (ans+calc(k+1, r-l-k+1))%mod;
 		if(i!=k-1) //第一个区间不用去重
		ans = (ans-calc(k, pos[i]-1-l-(k-1)+1)+mod)%mod; //去重，与前一个区间重复
		//重复的是(l, pos[i]-1)区间，里面有k-1个1
		l = pos[i-k+1]+1;
	}
	printf(&quot;%I64d\n&quot;, ans);
}
signed main()
{	
	init();
        sol();
}
</code></pre>
<h2 id = "2.2"><h2>
<h2 id="a-stable-arrangement-of-rooks"><a href="https://codeforces.com/contest/1621/problem/A">A. Stable Arrangement of Rooks</a></h2>
<p>题意：在n*n的棋盘上放置m个车，要求车移动到相邻的四个位置也不会与其他的车冲突，车类似于象棋中的车<br>
思路：对角线上放置，且在对角线要隔着一个，防止冲突</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 5100;
const int mod = 998244353;
int n, m;
char s[M][M];

void sol()
{
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 0; i &lt; n; ++i) {
		for(int j = 0; j &lt; n; ++j) s[i][j] = '.';
		s[i][n] = '\0';
	}
	if(n+1 &lt; 2*m) {
		puts(&quot;-1&quot;);
		return ;
	}
	for(int i = 0; i &lt; m; ++i)
		s[i*2][i*2] = 'R';
	for(int i = 0; i &lt; n; ++i)
		puts(s[i]);
}
signed main()
{	
    int _ = 1; scanf(&quot;%d&quot;, &amp;_);	while (_--)
        sol();
}
</code></pre>
<h2 id = "2.3"><h2>
<p><a href="https://codeforces.com/contest/1621/problem/B">B. Integers Shop</a><br>
思路：取<code>两端区间的最小值的和</code>  <code>包含所有数字区间的最小的值</code>两者的最小值</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
#define INF 0x7f7f7f7f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define eps 1e-10
#define pb push_back
#define fi first
#define se second
#define SZ(x) (int)x.size()
#define ALL(x) x.begin(), x.end()
#define db1(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl
#define db2(x, y) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; #y &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; endl
#define gg cout &lt;&lt; &quot;---------QAQ--------\n&quot;
#define MEM(a, b) memset(a, b, sizeof(a))
//#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(NULL);

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;pii, int&gt; piii;
const int N = 2e5+10, M = 5100;
const int mod = 998244353;

int n, m;
int l[N], r[N], c[N];
/*
左端最小的区间，右端最大的区间
*/

void sol()
{
	scanf(&quot;%d&quot;, &amp;n);
	int L = 1, R = 1;

	int temp = 1, ans = INF;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;l[i], &amp;r[i], &amp;c[i]);
		if(l[L] &gt; l[i]) L = i;
		else if(l[L]==l[i]&amp;&amp;c[L]&gt;c[i]) L = i;
		else if(l[L]==l[i]&amp;&amp;c[L]==c[i]&amp;&amp;r[L]&lt;r[i]) L = i;

		if(r[R] &lt; r[i]) R = i;
		else if(r[R]==r[i]&amp;&amp;c[R]&gt;c[i]) R = i;
		else if(r[R]==r[i]&amp;&amp;c[R]==c[i]&amp;&amp;l[L]&gt;l[i]) R = i;

		if(l[i]==l[L]&amp;&amp;r[i]==r[R]) {
			if(l[i]==l[temp]&amp;&amp;r[i]==r[temp]&amp;&amp;c[i]&lt;=c[temp])
				temp = i, ans = c[i]; 
			if(l[i]!=l[temp]||r[i]!=r[temp])
				temp = i, ans = c[i];
		}
		if(l[temp]!=l[L]||r[temp]!=r[R]) ans = INF;

		printf(&quot;%d\n&quot;, min(ans, c[L]+c[R]));
	}
}
signed main()
{	
    int _ = 1; scanf(&quot;%d&quot;, &amp;_);	while (_--)
        sol();
}
</code></pre>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zzulihrs.github.io/post/linux-ji-chu-ke/">
                  <h3 class="post-title">
                    Linux基础课
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
